#!/usr/bin/bash
## set the personal access token & key to github env. var secret
#declare wakaKey="$PERSONAL_WAKATIME_KEY"
#declare githubKey="$PERSONAL_GITHUB_TOKEN"
source api-keys #Temporary for testing the script
# dependencies: bash, sed, jq, printf, perl
declare flag="$1"
declare template="$2"
declare readme="$3"
## Check if flag is given or reassign variables
if [[ "$flag" != -* ]]; then
  flag=""
  template="$1"
  readme="$2"
fi
## Check if template and readme are right format or exit
[[ "$template" == *.tpl ]] || exit 1
[[ "$readme" == *.md ]] || exit 1

########################## general func start ##########################
_main() {
  local -a wakaComments=($(_checkHtmlComments wakatime))
  local -a services
  echo "start wakatime"
  [[ -z "${wakaComments[@]}" ]] || { services+=("wakatime"); _fetchWakaData; }

  echo "start github"
  local -a githubComments=($(_checkHtmlComments github))
  if [[ -n "${githubComments[@]}" ]]; then
    source queries
    declare services+=("github")
    ## Get username and id
    declare userData="$(_queryGithubData _printQueryUser)"
    declare user="$(jq -r .data.viewer.login <<< "$userData")"
    declare id="$(jq -r .data.viewer.id <<< "$userData")"
    declare since="$(date -u -d "$date -1 year" +"%FT%TZ")"
    [[ $flag == "-m" ]] && since="$(date -u -d "$date -1 month" +"%FT%TZ")"
    [[ $flag == "-c" ]] && since="$(jq -r .data.viewer.createdAt <<< "$userData")"
    ## difference between waka REST and github graphql, github
    ## requires already a looping over comments, because multiple queries
    ## are needed
    _fetchGithubData
  fi

  _writeReadme
}
_checkHtmlComments() {
  local service=$1
  ## Find all the html comment tags in the readme template and put them
  ## in an array.
  local -a commentsArray
  case "$service" in
    ## keywords/comments are existent in REST API. They are
    ## needed throughout the whole script to filter with jq and so on.
    wakatime) local -a lookupComments=("languages" "editors" "operating_systems" "projects" "timezone");;
    ## since graphql is used here, the keyword could be anything as queries are
    ## needed and filtering with jq works with more generic terms.
    github) #local -a lookupComments=("hire");;
    local -a lookupComments=("projectsOwn" "projectsAll" "projectsCount" "hire" "pullRequests" "zet" "forks" "stars" "gists" "followers" "sponsors" "languages" "productiveDay" "productiveTime");;
    ## future REST APIs should also be implemented with a keyword that
    #
    ## exists in the received JSON and is represented in the html comment.
  esac
  ## Loop over all possible comments from lookupComments and check if they
  ## can be found in template, if yes add them to wakaComments
  for lookupComment in "${lookupComments[@]}"; do
    checkCommentStartLine=$(grep -n "<!--$service-$lookupComment-start-->" "$template" | cut -c1,2)
    checkCommentEndLine=$(grep -n "<!--$service-$lookupComment-end-->" "$template" | cut -c1,2)
    if [[ $checkCommentStartLine -ne 0 && $checkCommentEndLine -ne 0 ]]; then
      #commentsArray+=("${lookupComment##*-}") # rm prefix waka, git etc.
      commentsArray+=("${lookupComment}") # rm prefix waka, git etc.
    fi
  done
  echo "${commentsArray[@]}"
}
############################# utility func #############################
_createTimeAgo() {
  local timestamp="$1"
  local pushedTimeSec="$(date -d "$timestamp" +%s)"
  local currentTimeSec=$(date -u +%s)
  local deltaTimeDays="$(((currentTimeSec - pushedTimeSec) / 86400))"
  case $deltaTimeDays in
    0) deltaTimeHours="$(((currentTimeSec - pushedTimeSec) / 3600))"
      echo "$deltaTimeHours hours ago";;
    1) echo "$deltaTimeDays day ago";;
    [2-7]) echo "$deltaTimeDays days ago";;
    [8-9]|1[0-4]) echo "1 week ago";;
    1[5-9]|2[0-1]) echo "2 weeks ago";;
    2[2-8]) echo "3 weeks ago";;
    29|3[0-9]|4[0-9]) echo "1 month ago";;
    ##TODO if more than 12 months make it 1 year, if more than 24
    #months make it 2 years and so on...
    *) ## round months up if remainder is higher than half a months days
      if [[ "$deltaTimeDays%30" -ge 15 ]]; then
        echo "$(((deltaTimeDays/30) + 1)) months ago"
      else
        echo "$((deltaTimeDays/30)) months ago"
      fi;;
  esac
}
_createStatusBar() {
  ## status bar total width/blocks
  width=25
  percent=$1
  ## calc with correct rounding amount of filled and empty blocks
  filled=$(bc -l <<< "($width * $percent) / 100")
  if (( $(echo "$filled - $(printf '%.0f' $filled) >= 0.5" | bc -l) )); then
    filled=$(bc -l <<< "$(printf '%.0f' $filled) + 1")
  else
    filled=$(printf '%.0f' $filled)
  fi
  empty=$(($width - $filled))
  block_filled="█"
  block_empty="░"
  ## $filled and $empty need to be +1 because this will print in beteween
  ## num 1-xx blocks and then remove 1-xx but because it's in between it's
  ## one short
  printf "%s%s\n" "$(seq -s "$block_filled" $((filled+1)) | sed 's/[0-9]//g')$(seq -s "$block_empty" $((empty+1)) | sed 's/[0-9]//g')"
}
############################## github func #############################
_queryGithubData() {
  ## query: `_queryGithubData _printQueryXXX`, $1 = printQueryXXX func,
  ## stored in 'queries' file
  query="$($1)"
  ## this echo $query without quotes is needed to get query on a single
  ## line, sed is needed to escape any double quotes in the query string
  ## both those things are needed for the curl command to work
  query="$(echo $query | sed 's/"/\\"/g' )"
  curl -s -H 'Content-Type: application/json' \
     -H "Authorization: bearer $githubKey" \
     -d "{ \"query\": \"$query\"}" https://api.github.com/graphql | jq '.'
}
############################# github fetch #############################
_fetchGithubData() {
  ## loop over all queries needed and fetch the different data.
  ## Data that requires more intensive processing is coming from
  ## individual _filterGithubXXX functions that filter and
  ## proccess data on their own. They being called from within
  ## _fetchGithubData and stored in arrays.
  local -A fetchGithubData=()
  for githubComment in "${githubComments[@]}"; do
    case $githubComment in
      projectsOwn) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposOwn)" );;
      projectsAll) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposAll)" );;
      projectsCount) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposTotal)" );;
      pullRequests) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryPullRequests)" );;
      zet) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryZet)" );;
      forks) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryForks)" );;
      stars) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryStars)" );;
      gists) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryGists)" );;
      followers) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryFollowers)" );;
      sponsors) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQuerySponsors)" );;
      ## queries which require multiple request because of githubs 100 entries
      ## cap are fetching data via their own functions
      languages) fetchGithubData+=( ["$githubComment"]="$(_fetchGithubLanguagesPages)" );;
      productiveDay) fetchGithubData+=( ["$githubComment"]="$(_fetchGithubProductiveRepoPages)" );;
      productiveTime) ## only request query if productiveDay dit not already do it
        if [[ -z "${fetchGithubData[productiveDay]}" ]]; then
          fetchGithubData+=( ["$githubComment"]="$(_fetchGithubProductiveRepoPages)" )
        else
          fetchGithubData+=( ["$githubComment"]="${fetchGithubData[productiveDay]}" )
        fi;;
    esac
  done
  #echo "${fetchGithubData[languages]}"
  _filterGithubData
}
_fetchGithubLanguagesPages() {
  local response; local data; local hasNextPage; local languageCursor
  # request first query
  response="$(_queryGithubData _printQueryLanguagesFirstPage)"
  ## add first 100 repos page with it's primary language
  data="$response"
  hasNextPage=$(jq '.data.search.pageInfo.hasNextPage' <<< $response)
  ## loop over all repo pages and keep adding new repo page data
  while [[ $hasNextPage == "true" ]]; do
    languageCursor=$(jq '.data.search.pageInfo.endCursor' <<< $response | tr -d '"')
    response="$(_queryGithubData _printQueryLanguagesNextPage)"
    data+="$response"
    hasNextPage=$(jq '.data.search.pageInfo.hasNextPage' <<< $response)
  done
  echo "$data"
}
_fetchGithubProductiveRepoPages() {
  local responseMain; local data; local repoHasNextPage; local repoCursor
  local -i iMax 
  # Call the first query
  responseMain="$(_queryGithubData _printQueryProductivityFirstRepoPage)"
  ## add first repo page with first 100 commits per repo to data
  data="$responseMain"
  repoHasNextPage=$(echo $responseMain | jq '.data.user.repositories.pageInfo.hasNextPage' )
  #local -i x=0
  ## set iMax according to whether or not more repo pages available
  [[ $repoHasNextPage = true ]] && iMax=2 ||
    iMax=$(echo $responseMain | jq '.data.user.repositories.totalCount' )
  ## check first repo page, if repos have more than 100 commmits add to data
  data+="$(_fetchGithubProductiveCommitPages)"
  ## outer loop: over all repo pages and add keep adding rest of commits
  while [[ $repoHasNextPage == "true" ]]; do
    #echo index repo x: $x
    repoCursor=$(echo $responseMain | jq '.data.user.repositories.pageInfo.endCursor' | tr -d '"')
    #echo repoCursor: $repoCursor
    ## get new repo page
    responseMain="$(_queryGithubData _printQueryProductivityNextRepoPage)"
    ## add first 100 commits from new repo page to data
    data+="$responseMain"
    ## check if new repo page has more than 100 commits and add to data
    ##FIXME the last repo page has not iMax=100 but would need the
    #remaining repos set as iMax, it works but it's just ugly this way
    data+="$(_fetchGithubProductiveCommitPages)"
    #_filterGithubProductiveDay && [[ $x == 3 ]] && exit
    ## check if more repo pages available
    repoHasNextPage=$(echo $responseMain | jq '.data.user.repositories.pageInfo.hasNextPage' | tr -d '"')
    #echo repoNextpage inside: $repoHasNextPage
    #x+=1
  done
  echo "$data"
}
_fetchGithubProductiveCommitPages() {
  local hasNextPage; local cursor; local response; local dataCommits
  local hasNextPageInside
  ## inner loop: over each repo with more than 100 commits
  for ((i = 0; i < $iMax; i++)); do
    hasNextPage="$(echo $responseMain | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage")"
    ## check if another page can is available if so second query is needed
    if [[ $hasNextPage == "true" ]]; then
      #echo index commmits: $i
      cursor="$(echo $responseMain | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.endCursor" | tr -d '"')"
      #echo cursor commit: $cursor
      ## check if _fetchGithubProductiveCommitPages is called first time
      if [[ -z $repoCursor ]]; then
        ## Call the next commit page query, without repoCursor set
        response="$(_queryGithubData _printQueryProductivityFirstRepoPageCommitPage)"
      else
        ## Call the next commit page query, with repoCursor set
        response="$(_queryGithubData _printQueryProductivityNextRepoPageNextCommitPage)"
      fi
      ## add second 100 commits to data
      dataCommits+="$response"
      hasNextPageInside="$(echo $response | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage")"
      #echo nextpage inside commit: $hasNextPageInside
    fi
    ## second inner commit loop: check if after the second query there is even more data, if so keep
    ## requesting data until end
    while [ "$hasNextPageInside" == "true" ]; do
      #echo index commits i: $i
      # Parse the end cursor and has next page values from the response
      cursor="$(echo $response | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.endCursor" | tr -d '"')"
      #echo cursor commit: $cursor
      ## check if _fetchGithubProductiveCommitPages is called first time
      if [[ -z $repoCursor ]]; then
        ## Call the next commit page query, without repoCursor set
        response="$(_queryGithubData _printQueryProductivityFirstRepoPageCommitPage)"
      else
        ## Call the next commit page query, with repoCursor set
        response="$(_queryGithubData _printQueryProductivityNextRepoPageNextCommitPage)"
      fi
      ## add third-end batch of 100 commits to data
      dataCommits+="$response"
      hasNextPageInside="$(echo $response | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage")"
      #echo nextpage inside again commit: $hasNextPageInside
    done
  done
  echo "$dataCommits"
}
############################# github filter ############################
_filterGithubData() {
  local -A filterGithubStart; local -A filterGithubMiddle
  local -A filterGithubEnd; local -A iMax
  local -a productivityDaytime; local -a productivityDay
  local -a topLanguages; local -a filter
  local filter0; local filter1; local filter2
  local repoName; local nameWithOwner; local urlRepo; local description
  local datestamp; local repoCount; local hireable; local urlRequest
  local titleRequest; local urlCommit; local isoSec; local commitMsg
  local urlGist; local fileName; local owner; local urlFollower
  local nameFollower; local workplaceFollower; local urlSponsor
  local nameSponsor
  ## loop to set iMax:
  for githubComment in "${githubComments[@]}"; do
    case "$githubComment" in
      projectsOwn|projectsAll) iMax[$githubComment]=7;;
      projectsCount) iMax[$githubComment]=2;;
      hire) iMax[$githubComment]=1;;
      pullRequests|zet|forks|stars|gists|followers|sponsors) iMax[$githubComment]=5;;
      ## special treatment with pre processing in own functions:
      languages) IFS=';' topLanguages=( $(_filterGithubLanguages) )
        iMax[$githubComment]=${topLanguages[0]}; local -i iLang=1;;
      productiveDay) IFS=';' productivityDay=( $(_filterGithubProductiveDay) )
        iMax[$githubComment]=7; local -i iDay=0;;
      productiveTime) IFS=';' productivityDaytime=( $(_filterGithubProductiveTime) )
        iMax[$githubComment]=4; local -i iTime=0;;
    esac
  done
  ## outer comment loop:
  for githubComment in "${githubComments[@]}"; do
    ## inner index loop 1 for keywords that can be easily processed
    ## DEBUG:
    #echo "$githubComment iMax: ${iMax[$githubComment]}"
    for ((i = 0; i < ${iMax[$githubComment]}; i++)); do
      case $githubComment in
        projectsOwn|projectsAll)
          filter=(".data.user.repositories.edges[$i]" ".node")
          repoName="$(jq -r "${filter[0]} | ${filter[1]}.name" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found. Because User does not
          ## have sufficient repos
          [[ $repoName == null ]] && break
          ## skip github profile and zet repo
          [[ "$repoName" == "$user" || "$repoName" == zet ]] && continue
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.pushedAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
        projectsCount) filter=(".data.user.publicRepositories.totalCount" ".data.user.privateRepositories.totalCount")
          repoCount="$(jq -r "${filter[$i]}" <<< ${fetchGithubData[$githubComment]})"
          ## skip inner loop if no data found
          [[ $repoCount == null ]] && continue
          filter0="* 💾"
          filter1="$repoCount"
          ## filter2 first element is public second is Private
          if [[ "$i" == 0 ]]; then
            [[ "$filter1" == 1 ]] && filter2="Public Repository"              \
              || filter2="Public Repositories"
          else
            [[ "$filter1" == 1 ]] && filter2="Private Repository"             \
              || filter2="Private Repositories"
          fi;;
        hire) filter1=""; filter2=""
          hireable="$(jq -r .data.viewer.isHireable <<< $userData)"
          [[ "$hireable" == true ]] && filter0="> 💼 Open for hire now"       \
            || filter0="> 🚫 Not available for hire" ;;
        pullRequests) filter=(".data.search.edges[$i]" ".node")
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.repository.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ $nameWithOwner == null ]] && break
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.repository.url" <<< ${fetchGithubData[$githubComment]})"
          urlRequest="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          titleRequest="$(jq -r "${filter[0]} | ${filter[1]}.title" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.mergedAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$titleRequest]($urlRequest)"
          filter1="on ["$nameWithOwner"]($urlRepo)"
          filter2="($datestamp)";;
        zet) filter=(".data.repository.refs.edges[$i]" ".node.target" ".node.name" )
          [[ $i == 0 ]] && nameWithOwner="$(jq -r ".data.repository.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ $nameWithOwner == null ]] && break
          urlCommit="$(jq -r "${filter[0]} | ${filter[1]}.treeUrl" <<< ${fetchGithubData[$githubComment]})"
          isoSec="$(jq -r "${filter[0]} | ${filter[2]}" <<< ${fetchGithubData[$githubComment]})"
          commitMsg="$(jq -r "${filter[0]} | ${filter[1]}.message" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.committedDate" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlCommit/$isoSec)"
          filter1="- $commitMsg"
          filter2="($datestamp)";;
        forks) filter=(".data.user.repositories.edges[$i]" ".node")
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlRepo" == null ]] && break
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
        stars) filter=(".data.user.starredRepositories.edges[$i]" ".node" ".starredAt")
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlRepo" == null ]] && break
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[2]}" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
          #echo "0: $filter0 1: $filter1 2: $filter2"
        gists) filter=(".data.user.gists.edges[$i]" ".node")
          urlGist="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlGist" == null ]] && break
          fileName="$(jq -r "${filter[0]} | ${filter[1]}.files[0].name" <<< ${fetchGithubData[$githubComment]})"
          owner="$(jq -r "${filter[0]} | ${filter[1]}.owner.login" <<< ${fetchGithubData[$githubComment]})"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$owner/$fileName]($urlGist)"
          filter1="- $description"
          filter2="($datestamp)";;
        followers) filter=(".data.user.followers.edges[$i]" ".node")
          urlFollower="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlFollower" == null ]] && break
          nameFollower="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< ${fetchGithubData[$githubComment]})"
          workplaceFollower="$(jq -r "${filter[0]} | ${filter[1]}.company" <<< ${fetchGithubData[$githubComment]})"
          filter0="* [$nameFollower]($urlFollower)"
          [[ "$workplaceFollower" == null ]] && filter1="- 💼 Unknown"        \
            || filter1="- 💼 $workplaceFollower"
          filter2="";;
        sponsors) filter=(".data.user.sponsorshipsAsMaintainer.nodes[$i]" ".sponsorEntity" ".createdAt")
          urlSponsor="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlSponsor" == null ]] && break
          nameSponsor="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[2]}" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameSponsor]($urlSponsor)"
          filter1="($datestamp)"
          filter2="";;
        languages)
          filter0="* ${topLanguages[$iLang]}"
          x=$((iLang+iMax[$githubComment]))
          filter1="${topLanguages[$x]}"
          [[ "$filter1" == 1 ]] && filter1="$filter1 repo"                    \
            || filter1="$filter1 repos"
          ## increment xx (iMax) to skip to percentage elements
          x=$((x+iMax[$githubComment]))
          filter2="$(_createStatusBar "${topLanguages[$x]}")   ${topLanguages[$x]}%"
          iLang+=1;;
        productiveDay)
          filter0="* ${productivityDay[$iDay]}"
          ## increment 7 (days) to skip to commitCount elements
          x=$((iDay+7))
          filter1="${productivityDay[$x]}"
          ## add commit or commits according to counted num
          [[ "$filter1" == 1 ]] && filter1="$filter1 commit"                  \
            || filter1="$filter1 commits"
          ## increment 7 (days) to skip to percentage elements
          x=$((x+7))
          filter2="$(_createStatusBar "${productivityDay[$x]}")   ${productivityDay[$x]}%"
          iDay+=1;;
        productiveTime)
          filter0="* ${productivityDaytime[$iTime]}"
          ## increment 4 (daytimes) to skip to commitCount elements
          x=$((iTime+4))
          filter1="${productivityDaytime[$x]}"
          [[ "$filter1" == 1 ]] && filter1="$filter1 commit"                  \
            || filter1="$filter1 commits"
          x=$((x+4))
          ## increment 4 (daytimes) to skip to percentage elements
          filter2="$(_createStatusBar "${productivityDaytime[$x]}")   ${productivityDaytime[$x]}%"
          iTime+=1;;
      esac
      ##DEBUG:
      #echo "0: $filter0 1: $filter1 2: $filter2"
      ## create three arrays with filter strings
      filterGithubStart+=( ["${githubComment}$i"]="$filter0" )
      filterGithubMiddle+=( ["${githubComment}$i"]="$filter1" )
      filterGithubEnd+=( ["${githubComment}$i"]="$filter2" )
    done
  done
  _writeGithubTemplate
}
############################# github write #############################
_writeGithubTemplate() {
  local content
  for githubComment in "${githubComments[@]}"; do
    ## create block
    content="$(_createGithubMarkdownBlock $githubComment)"
    ## write block
    perl -i -0777pe "s@<!--github-$githubComment-start-->\s*<!--github-$githubComment-end-->@<!--github-$githubComment-start-->\n${content}\n  <!--github-$githubComment-end-->@s" "$template"
  done
}
_createGithubMarkdownBlock() {
  local commentArg="$1"
  local space0=0; local space1=0; local space2=0
  for ((i = 0; i < ${iMax[$commentArg]}; i++)); do
    ## check if data is still found, if not skip loop to avoid printing
    #empty lines
    [[ -n "${filterGithubStart["${commentArg}$i"]}" ]] || continue
    ## set space for formatting text
    case "$commentArg" in
      languages) space0=20; space1=20;;
      productiveDay) space0=20; space1=20;;
      productiveTime) space0=22; space1=20;;
    esac
    ## generic print statement:
    printf "%-*s %-*s %-*s\n" $space0 "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}"
  done
}
########################### github pre filter ##########################
_filterGithubLanguages() {
  local -A reposCount; local -A percentage
  ## if response of primary language is null it does not give "name": "foo"
  ## line, hence directly greping name with wc works
  local -i totalReposCount=$(grep '"name"' <<< "${fetchGithubData[languages]}" | wc -l)
  local language; local -i totalLanguagesCount=0
  ## count repos per language
  while read line; do
    if [[ $line =~ \"name\":.* ]]; then
      language="$(grep -o ':.*' <<< $line | sed 's|^...||' | tr -d '"')"
      reposCount[$language]=$((reposCount[$language]+1))
    fi
  done < <(echo "${fetchGithubData[languages]}")
  ## calculate percentage
  for language in "${!reposCount[@]}"; do
    percentage[$language]="$(printf "%.2f\n" $(bc -l <<< "(${reposCount[$language]} / $totalReposCount) * 100"))"
    totalLanguagesCount+=1
  done

  echo "${totalLanguagesCount};${!reposCount[*]};${reposCount[*]};${percentage[*]}"
}
_filterGithubProductiveDay() {
  local -A commitCount; local -A percentage
  local -a weekdays=( "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday" )
  local -i totalCommitCount=$(grep "committedDate" <<< "${fetchGithubData[productiveDay]}" | wc -l)
  local datestamp; local weekday
  ## count commits per weekday
  while read line; do
    if [[ $line =~ committedDate.* ]]; then
      datestamp="$(echo "$line" | grep -o ':.*Z' | sed 's|^...||')"
      weekday="$(date -d "$datestamp" +%A)"
      commitCount[$weekday]=$((commitCount[$weekday]+1))
    fi
  done < <(echo "${fetchGithubData[productiveDay]}")
  #for weekday in "${!commitCount[@]}"; do
  #  echo "Commits on $weekday: ${commitCount[$weekday]}"
  #done
  ## calculate percentage of counted weekdays
  for weekday in "${weekdays[@]}"; do
    if [[ -z ${commitCount[$weekday]} ]]; then
      commitCount[$weekday]="0"
      percentage[$weekday]="0.00"
    else
      percentage[$weekday]="$(printf "%.2f\n" $(bc -l <<< "(${commitCount[$weekday]} / $totalCommitCount) * 100"))"
    fi
  done

  echo "${weekdays[*]};${commitCount[*]};${percentage[*]}"
}
_filterGithubProductiveTime() {
  local -A commitCount; local -A percentage
  local -i totalCommitCount=$(grep "committedDate" <<< "${fetchGithubData[productiveDay]}" | wc -l)
  local datestamp; local timestamp; local -i hours; local -i minutes
  local -a daytimes=( "Morning" "Daytime" "Evening" "Night" )
  ## count commits per daytime
  while read line; do
    if [[ $line =~ committedDate.* ]]; then
      datestamp="$(echo "$line" | grep -o ':.*Z' | sed 's|^...||')"
      ## truncate date from datestamp, only time needed
      timestamp="${datestamp##*T}"
      ## get hours
      hours="$(cut -d: -f1 <<< $timestamp)"
      ## get minutes, sed needed to rm first 0 for minutes 01-09 otherwise remainder errors, minute 00 is fine just one 0 gets removed
      minutes="$(cut -d: -f2 <<< $timestamp | sed 's|^0||')"
      #echo $timestamp
      #echo $hours-$minutes
      if [[ "$minutes%60" -ge 30 ]]; then
        hours+=1
        [[ $hours -eq 24 ]] && hours=0
      fi
      #echo $hours-$minutes
      case $hours in
        [0-5]) commitCount[Night]=$((commitCount[Night]+1));;
        [6-9]|1[0-1]) commitCount[Morning]=$((commitCount[Morning]+1));;
        1[2-7]) commitCount[Daytime]=$((commitCount[Daytime]+1));;
        1[8-9]|2[0-3]) commitCount[Evening]=$((commitCount[Evening]+1));;
      esac
    fi
  done < <(echo "${fetchGithubData[productiveTime]}")
  ## calculate percentage of counted daytimes
  for daytime in "${daytimes[@]}"; do
    if [[ -z ${commitCount[$daytime]} ]]; then
      commitCount[$daytime]="0"
      percentage[$daytime]="0.00"
    else
      percentage[$daytime]="$(printf "%.2f\n" $(bc -l <<< "(${commitCount[$daytime]} / $totalCommitCount) * 100"))"
    fi
  done
  ## add emojis to daytimes
  daytimes=( "🌅 Morning" "🌞 Daytime" "🌇 Evening" "🌃 Night" )

  echo "${daytimes[*]};${commitCount[*]};${percentage[*]}"
}
############################# wakatime func ############################
_fetchWakaData() {
  local fetchWakaData=$(curl https://wakatime.com/api/v1/users/current/stats/last_7_days?api_key="$wakaKey" | jq '.')
  #echo $fetchWakaData
  #exit
  _filterWakaData
}
_filterWakaData() {
  ##  Declare local variables: strings, integers and arrays
  local -A filterWakaName=()
  local -A filterWakaPercent=()
  local -A filterWakaText=()
  local -A filterWakaLines=()
  ## Create associative arrays with data, use comment as outer loop and
  ## line number as inner loop. Uses line number  as max. index to
  ## iterate over. The same jq filter needs to be used again, mainly
  ## because when we retrive data we don't know how many objects are
  ## coming in.
  for wakaComment in "${wakaComments[@]}"; do
    ## check if wakaComment is timezone
    if [[ "$wakaComment" == timezone ]]; then
      filterWakaLines+=( ["$wakaComment"NameLines]="1" )
      filterWakaName+=( ["${wakaComment}0"]="* $(jq -r ".data.timezone" <<< "$fetchWakaData")" )
      ## skip rest of loop for timezone
      continue
    fi
    ## Get the total number of lines for each data element and store it
    ## in associative array. Since each element is on a own line the line
    ## number represent the number of elements for each comment.
    filterWakaLines+=( ["$wakaComment"NameLines]="$(jq -r ".data.$wakaComment | .[] | .name" <<< "$fetchWakaData" | wc -l)" )
    filterWakaLines+=( ["$wakaComment"PercentLines]="$(jq -r ".data.$wakaComment | .[] | .percent" <<< "$fetchWakaData" | wc -l)" )
    filterWakaLines+=( ["$wakaComment"TextLines]="$(jq -r ".data.$wakaComment | .[] | .text" <<< "$fetchWakaData" | wc -l)" )
    ## test if lines per wakaComment are the same on each filtered variable, or continue with next comment
    [[ ${filterWakaLines["$wakaComment"NameLines]} -eq ${filterWakaLines["$wakaComment"PercentLines]} && \
      ${filterWakaLines["$wakaComment"NameLines]} -eq ${filterWakaLines["$wakaComment"TextLines]} ]] || break
    ## Create associavtive array from data: Name, Percentage, Timestamp
    ## loops over max. elements found per comment
    for ((i = 0; i < "${filterWakaLines["${wakaComment}NameLines"]}"; i++)); do
      filterWakaName+=( ["${wakaComment}$i"]="* $(jq -r ".data.$wakaComment | .[$i] | .name" <<< "$fetchWakaData")" )
      filterWakaPercent+=( ["${wakaComment}$i"]="$(jq -r ".data.$wakaComment | .[$i] | .percent" <<< "$fetchWakaData")" )
      filterWakaPercent["${wakaComment}$i"]="$(_createStatusBar "${filterWakaPercent["${wakaComment}$i"]}")   ${filterWakaPercent["${wakaComment}$i"]}%"
      filterWakaText+=( ["${wakaComment}$i"]="$(jq -r ".data.$wakaComment | .[$i] | .text" <<< "$fetchWakaData")" )
    done
  done
  ##DEBUG:
  #echo "${filterWakaName[*]} ${filterWakaPercent[*]} ${filterWakaText[*]}"
_writeWakaTemplate
}
_writeWakaTemplate() {
  local callFunction
  if [[ "$flag" == "-H" ]]; then
    callFunction="_createWakaHtmlBlock"
  else
    callFunction="_createWakaMarkdownBlock"
  fi
  for wakaComment in "${wakaComments[@]}"; do
    content="$($callFunction $wakaComment)"
    perl -i -0777pe "s|<!--wakatime-$wakaComment-start-->\s*<!--wakatime-$wakaComment-end-->|<!--wakatime-$wakaComment-start-->\n${content}\n  <!--wakatime-$wakaComment-end-->|s" "$template"
  done
}
_createWakaMarkdownBlock() {
  local commentArg="$1"
  local space0=20; local space1=20; local space2=0
  for ((i = 0; i < ${filterWakaLines["${commentArg}NameLines"]}; i++)); do
    ## check if data is still found, if not skip loop to avoid printing
    #empty lines
    [[ -n "${filterWakaName["${commentArg}$i"]}" ]] || continue
    ## set space for formatting text
    case "$commentArg" in
      timezone) space0=0; space1=0;;
    esac
  ## generic print statement:
  printf "%-*s %-*s %-*s\n" $space0 "${filterWakaName["${commentArg}$i"]}" $space1 "${filterWakaText["${commentArg}$i"]}" $space2 "${filterWakaPercent["${commentArg}$i"]}"
  done
}
_createWakaHtmlBlock() {
  ##FIXME DRY maybe it's possible to only have one generic function
  ## _createHtmlBlock which works for all services. And uses code it has
  ## in common with other services.
  local commentArg="$1"
  local languagesHtmlBlock='<h4>💬 Languages:</h4>'
  local editorsHtmlBlock='<h4>📝 Editors:</h4>'
  local operating_systemsHtmlBlock='<h4>💻 Operating Systems:</h4>'
  local projectsHtmlBlock='<h4>🌱 Projects:</h4>'
  local timezoneHtmlBlock='<h4>🕐 Timezone:</h4>'
  ## Indirect reference to assign variables in loop.
  local -n htmlBlock=${commentArg}HtmlBlock
  if [[ "$commentArg" == timezone ]]; then
    htmlBlock+="\n<span>${filterWakaName["${commentArg}0"]:2}</span>"
    printf "%s" "$htmlBlock" && return 0
  fi
  for ((i = 0 ; i < "${filterWakaLines["${commentArg}NameLines"]}" ; i++)); do
    htmlBlock+="\n<span>${filterWakaName["${commentArg}$i"]:2}</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>${filterWakaText["${commentArg}$i"]}</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>${filterWakaPercent["${commentArg}$i"]}</span>"
  done
  printf "%s" "$htmlBlock"
}
########################### general func end ###########################
_writeReadme() {
  ## Update new API data/content into readme
  cat "$template" > "$readme"
  _cleanUpFiles
}
_cleanUpFiles() {
  local -a comments
  for service in "${services[@]}"; do
    [[ $service == github ]] && comments=("${githubComments[@]}")
    [[ $service == wakatime ]] && comments=("${wakaComments[@]}")
    for comment in "${comments[@]}"; do
      ## remove comments from README.md
      sed -i "/<!--$service-$comment-start-->/d" "$readme"
      sed -i "/<!--$service-$comment-end-->/d" "$readme"
      ## remove content between comments from template
      perl -i -0777pe "s/<!--$service-$comment-start-->.*<!--$service-$comment-end-->/<!--$service-$comment-start-->\n  <!--$service-$comment-end-->/s" "$template"
    done
  done
}
_main
