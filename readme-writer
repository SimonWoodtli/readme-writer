#!/usr/bin/bash
## set the personal access token & key to github env. var secret
#declare wakaKey="$PERSONAL_WAKATIME_KEY"
#declare githubKey="$PERSONAL_GITHUB_TOKEN"
source api-keys #Temporary for testing the script
# dependencies: bash, sed, jq, printf, perl
declare flag="$1"
declare template="$2"
declare readme="$3"
## Check if flag is given or reassign variables
if [[ "$flag" != -* ]]; then
  flag=""
  template="$1"
  readme="$2"
fi
## Check if template and readme are right format or exit
[[ "$template" == *.tpl ]] || exit 1
[[ "$readme" == *.md ]] || exit 1

##TODO IMPORTANT

## github graphql api:
## grab:
## * projectsAll: Your recent contributions
## * projectsOwn: Your recent projects
## * pullRequests: Your recent pull requests
## * forks: Forks you recently created
## * stars: Repositories you recently starred
## * gists: Your published gists
## * followers: Your latest followers
## * sponsors: Your sponsors
## * ??: (Recent releases you contributed to), not sure if I want that
#
## * languages: Gather info about which language is used percentage wise in which
## repo and create a list of top used languages from total of all repos
## * productiveDay: Which day of the week you are most productive messured by the
## amounts of commits
## * productiveTime: Which time of the day you are most productive messured by the amount
## of commits
## * stats: some github stats - amount of commits in current year, - amount of
## public&private repos, - opted for hire, - total github storage space
## used
########################## general func start ##########################
_main() {
  #local -a wakaComments=($(_checkHtmlComments wakatime))
  #echo "start wakatime"
  #[[ -z "${wakaComments[@]}" ]] || { service="wakatime"; _fetchWakaData; }
  echo "start github"
  local -a githubComments=($(_checkHtmlComments github))
  if [[ -n "${githubComments[@]}" ]]; then
    source queries
    declare service="github"
    ## Get username and id
    declare userData="$(_queryGithubData _printQueryUser)"
    declare user="$(jq -r .data.viewer.login <<< "$userData")"
    declare id="$(jq -r .data.viewer.id <<< "$userData")"
    declare since="$(date -u -d "$date -1 year" +"%FT%TZ")"
    [[ $flag == "-m" ]] && since="$(date -u -d "$date -1 month" +"%FT%TZ")"
    [[ $flag == "-c" ]] && since="$(jq -r .data.viewer.createdAt <<< "$userData")"


    #declare dateOneMonthAgo="$(date -u -d "$date -30 days" +"%FT%TZ")"
    #declare dateUserCreated="$(jq -r .data.viewer.createdAt <<< "$userData")"
    #dateUserCreated="${dateUserCreated%T*}"
    #declare dateOneYearAgo="$(date -u -d "$date -365 days" +"%FT%TZ")"



    #yearMonthDay

    ## difference between waka REST and github graphql, github
    #requires already a looping over comments, because multiple queries
    #are needed
    _fetchGithubData
  fi
}
_checkHtmlComments() {
  local service=$1
  ## Find all the html comment tags and put them in an array.
  local -a commentsArray
  case "$service" in
    ## keywords/comments are existent in REST API. They are
    ## needed throughout the whole script to filter with jq and so on.
    wakatime) local -a lookupComments=("languages" "editors" "operating_systems" "projects" "timezone");;
    ## since graphql is used here, the keyword could be anything as queries are
    ## needed and filtering with jq works with more generic terms.
    github) local -a lookupComments=("productiveTime" "productiveDay") ;;
    #local -a lookupComments=("projectsOwn" "projectsAll" "projectsCount" "hire" "pullRequests" "zet" "forks" "stars" "gists" "followers" "sponsors" "languages" "productiveDay" "productiveTime");;
    #
    #
    #
## * timezone: Timezone you are currently in
    ## future REST APIs should also be implemented with a keyword that
    ## exists in the received JSON and is represented in the html comment.
  esac
  ## Loop over all possible comments from lookupComments and check if they
  ## can be found in template, if yes add them to wakaComments
  for lookupComment in "${lookupComments[@]}"; do
    checkCommentStartLine=$(grep -n "<!--$service-$lookupComment-start-->" "$template" | cut -c1,2)
    checkCommentEndLine=$(grep -n "<!--$service-$lookupComment-end-->" "$template" | cut -c1,2)
    if [[ $checkCommentStartLine -ne 0 && $checkCommentEndLine -ne 0 ]]; then
      #commentsArray+=("${lookupComment##*-}") # rm prefix waka, git etc.
      commentsArray+=("${lookupComment}") # rm prefix waka, git etc.
    fi
  done
  echo "${commentsArray[@]}"
}
############################## github func #############################
_queryGithubData() {
  ## query: `_queryGithubData _printQueryXXX`, $1 = printQueryXXX func,
  ## stored in 'queries' file
  query="$($1)"
  ## this echo $query without quotes is needed to get query on a single
  ## line, sed is needed to escape any double quotes in the query string
  ## both those things are needed for the curl command to work
  query="$(echo $query | sed 's/"/\\"/g' )"
  curl -s -H 'Content-Type: application/json' \
     -H "Authorization: bearer $githubKey" \
     -d "{ \"query\": \"$query\"}" https://api.github.com/graphql | jq '.'
}

_fetchGithubData() {
  ## loop over all queries needed and fetch the different data.
  ## data that requires more intensive processing is coming from
  ## individual _filterGithubXXX functions that fetch, filter and
  ## proccess data on their own. They being called from within
  ## _fetchGithubData and stored in Arrays.
  local -A fetchGithubData=()
  for githubComment in "${githubComments[@]}"; do
    case $githubComment in
      projectsOwn) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposOwn)" );;
      projectsAll) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposAll)" );;
      projectsCount) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposTotal)" );;
      pullRequests) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryPullRequests)" );;
      zet) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryZet)" );;
      forks) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryForks)" );;
      stars) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryStars)" );;
      gists) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryGists)" );;
      followers) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryFollowers)" );;
      sponsors) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQuerySponsors)" );;
      languages) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryLanguages)" );;
      #productiveDay) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryProductivity)" );;
      #productiveTime) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryProductivity)" );;

      productiveDay) fetchGithubData+=( ["$githubComment"]="$(_fetchGithubProductiveRepoPages)" );;
      productiveTime) fetchGithubData+=( ["$githubComment"]="$(_fetchGithubProductiveRepoPages)" );;
    esac
  done
  #echo "${fetchGithubData[productiveDay]}"

  _filterGithubData
}

_fetchGithubProductiveRepoPages() {
  # Call the first query
  responseMain="$(_queryGithubData _printQueryProductivityFirstRepoPage)"
  ## add first repo page with first 100 commits per repo to data
  data="$responseMain"
  repoHasNextPage=$(echo $responseMain | jq '.data.user.repositories.pageInfo.hasNextPage' )
  local -i iMax
  local -i x=0
  ## set iMax according to whether or not more repo pages available
  [[ $repoHasNextPage = true ]] && iMax=2 ||
    iMax=$(echo $responseMain | jq '.data.user.repositories.totalCount' )
  ## check first repo page, if repos have more than 100 commmits add to data
  data+="$(_fetchGithubProductiveCommitPages)"

  ## loop over all repo pages and add keep adding commits
  while [[ $repoHasNextPage == "true" ]]; do
    #echo index repo x: $x
    repoCursor=$(echo $responseMain | jq '.data.user.repositories.pageInfo.endCursor' | tr -d '"')
    #echo repoCursor: $repoCursor
    ## get new repo page
    responseMain="$(_queryGithubData _printQueryProductivityNextRepoPage)"
    ## add first 100 commits from new repo page to data
    data+="$responseMain"
    ## check if new repo page has more than 100 commits and add to data
    ##FIXME the last repo page has not iMax=100 but would need the
    #remaining repos set as iMax
    data+="$(_fetchGithubProductiveCommitPages)"
    #_filterGithubProductiveDay && [[ $x == 3 ]] && exit
    ## check if more repo pages available
    repoHasNextPage=$(echo $responseMain | jq '.data.user.repositories.pageInfo.hasNextPage' | tr -d '"')
    #echo repoNextpage inside: $repoHasNextPage
    x+=1
  done
  echo "$data"
}
_fetchGithubProductiveCommitPages() {
  ## inner commit loop over total counted repos
  #hasNextPage=true
  for ((i = 0; i < $iMax; i++)); do
    hasNextPage="$(echo $responseMain | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage")"
    ## check if another page can is available if so second query is needed
    if [[ $hasNextPage == "true" ]]; then
      #echo index commmits: $i
      cursor="$(echo $responseMain | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.endCursor" | tr -d '"')"
      #echo cursor commit: $cursor
      ## check if _fetchGithubProductiveCommitPages is called first time
      if [[ -z $repoCursor ]]; then
        ## Call the next commit page query, without repoCursor set
        response="$(_queryGithubData _printQueryProductivityFirstRepoPageCommitPage)"
      else
        ## Call the next commit page query, with repoCursor set
        response="$(_queryGithubData _printQueryProductivityNextRepoPageNextCommitPage)"
      fi
      ## add second 100 commits to data
      dataCommits+="$response"
      hasNextPageInside="$(echo $response | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage")"
      #echo nextpage inside commit: $hasNextPageInside
    fi
    ## second inner commit loop: check if after the second query there is even more data, if so keep
    ## requesting data until end
    while [ "$hasNextPageInside" == "true" ]; do
      #echo index commits i: $i
      # Parse the end cursor and has next page values from the response
      cursor="$(echo $response | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.endCursor" | tr -d '"')"
      #echo cursor commit: $cursor
      ## check if _fetchGithubProductiveCommitPages is called first time
      if [[ -z $repoCursor ]]; then
        ## Call the next commit page query, without repoCursor set
        response="$(_queryGithubData _printQueryProductivityFirstRepoPageCommitPage)"
      else
        ## Call the next commit page query, with repoCursor set
        response="$(_queryGithubData _printQueryProductivityNextRepoPageNextCommitPage)"
      fi
      ## add third-end batch of 100 commits to data
      dataCommits+="$response"
      hasNextPageInside="$(echo $response | jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage")"
      #echo nextpage inside again commit: $hasNextPageInside
    done
  done
  echo "$dataCommits"
}

_filterGithubData() {
  local -A filterGithubStart; local -A filterGithubMiddle
  local -A filterGithubEnd; local -A iMax
  local -a productivityDaytime; local -a productivityDay
  local -a topLanguages; local -a filter
  #_filterGithubProductiveDay
  #_filterGithubProductiveTime
  #exit

  ## loop to set iMax:
  for githubComment in "${githubComments[@]}"; do
    case "$githubComment" in
      projectsOwn|projectsAll) iMax[$githubComment]=7;;
      projectsCount) iMax[$githubComment]=2;;
      hire) iMax[$githubComment]=1;;
      pullRequests|zet|forks|stars|gists|followers|sponsors) iMax[$githubComment]=5;;
      ## special treatment with pre processing in own functions:
      languages) topLanguages=( $(_filterGithubTopLanguages) )
        iMax[$githubComment]=${topLanguages[0]}; local -i iLang=1;;
      productiveDay) IFS=';' productivityDay=( $(_filterGithubProductiveDay) )
        iMax[$githubComment]=7; local -i iDay=0;;
      productiveTime) IFS=';' productivityDaytime=( $(_filterGithubProductiveTime) )
        iMax[$githubComment]=4; local -i iTime=0;;
    esac
  done


  ## outer comment loop:
  for githubComment in "${githubComments[@]}"; do
    ## inner index loop 1 for keywords that can be easily processed
    echo "$githubComment iMax: ${iMax[$githubComment]}"
    for ((i = 0; i < ${iMax[$githubComment]}; i++)); do
      case $githubComment in
        projectsOwn|projectsAll)
          filter=(".data.user.repositories.edges[$i]" ".node")
          repoName="$(jq -r "${filter[0]} | ${filter[1]}.name" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found. Because User does not
          ## have sufficient repos
          [[ $repoName == null ]] && break
          ## skip github profile and zet repo
          [[ "$repoName" == "$user" || "$repoName" == zet ]] && continue
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.pushedAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
        projectsCount) filter=(".data.user.publicRepositories.totalCount" ".data.user.privateRepositories.totalCount")
          repoCount="$(jq -r "${filter[$i]}" <<< ${fetchGithubData[$githubComment]})"
          ## skip inner loop if no data found
          [[ $repoCount == null ]] && continue
          filter0="* 💾"
          filter1="$repoCount"
          ## filter2 first element is public second is Private
          if [[ "$i" == 0 ]]; then
            [[ "$filter1" == 1 ]] && filter2="Public Repository"               \
              || filter2="Public Repositories"
          else
            [[ "$filter1" == 1 ]] && filter2="Private Repository"              \
              || filter2="Private Repositories"
          fi;;
        hire) filter1=""; filter2=""
          hireable="$(jq -r .data.viewer.isHireable <<< $userData)"
          [[ "$hireable" == true ]] && filter0="> 💼 Open for hire now"       \
            || filter0="> 🚫 Not available for hire" ;;
        pullRequests) filter=(".data.search.edges[$i]" ".node")
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.repository.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ $nameWithOwner == null ]] && break
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.repository.url" <<< ${fetchGithubData[$githubComment]})"
          urlRequest="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          titleRequest="$(jq -r "${filter[0]} | ${filter[1]}.title" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.mergedAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$titleRequest]($urlRequest)"
          filter1="on ["$nameWithOwner"]($urlRepo)"
          filter2="($datestamp)";;
        zet) filter=(".data.repository.refs.edges[$i]" ".node.target" ".node.name" )
          [[ $i == 0 ]] && nameWithOwner="$(jq -r ".data.repository.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ $nameWithOwner == null ]] && break
          urlCommit="$(jq -r "${filter[0]} | ${filter[1]}.treeUrl" <<< ${fetchGithubData[$githubComment]})"
          isoSec="$(jq -r "${filter[0]} | ${filter[2]}" <<< ${fetchGithubData[$githubComment]})"
          commitMsg="$(jq -r "${filter[0]} | ${filter[1]}.message" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.committedDate" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlCommit/$isoSec)"
          filter1="- $commitMsg"
          filter2="($datestamp)";;
        forks) filter=(".data.user.repositories.edges[$i]" ".node")
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlRepo" == null ]] && break
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
        stars) filter=(".data.user.starredRepositories.edges[$i]" ".node" ".starredAt")
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlRepo" == null ]] && break
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< ${fetchGithubData[$githubComment]})"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[2]}" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
          #echo "0: $filter0 1: $filter1 2: $filter2"
        gists) filter=(".data.user.gists.edges[$i]" ".node")
          urlGist="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlGist" == null ]] && break
          fileName="$(jq -r "${filter[0]} | ${filter[1]}.files[0].name" <<< ${fetchGithubData[$githubComment]})"
          owner="$(jq -r "${filter[0]} | ${filter[1]}.owner.login" <<< ${fetchGithubData[$githubComment]})"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$owner/$fileName]($urlGist)"
          filter1="- $description"
          filter2="($datestamp)";;
        followers) filter=(".data.user.followers.edges[$i]" ".node")
          urlFollower="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlFollower" == null ]] && break
          nameFollower="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< ${fetchGithubData[$githubComment]})"
          workplaceFollower="$(jq -r "${filter[0]} | ${filter[1]}.company" <<< ${fetchGithubData[$githubComment]})"
          filter0="* [$nameFollower]($urlFollower)"
          [[ "$workplaceFollower" == null ]] && filter1="- 💼 Unknown"        \
            || filter1="- 💼 $workplaceFollower"
          filter2="";;
        sponsors) filter=(".data.user.sponsorshipsAsMaintainer.nodes[$i]" ".sponsorEntity" ".createdAt")
          urlSponsor="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< ${fetchGithubData[$githubComment]})"
          ## break inner loop if no data found
          [[ "$urlSponsor" == null ]] && break
          nameSponsor="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< ${fetchGithubData[$githubComment]})"
          datestamp="$(_createGithubTimeAgo "$(jq -r "${filter[0]} | ${filter[2]}" <<< ${fetchGithubData[$githubComment]})")"
          filter0="* [$nameSponsor]($urlSponsor)"
          filter1="($datestamp)"
          filter2="";;
        languages)
          filter0="* ${topLanguages[$iLang]}"
          filter1="${topLanguages[$((iLang+1))]}"
          [[ "$filter1" == 1 ]] && filter1="$filter1 repo"                    \
            || filter1="$filter1 repos"
          filter2="${topLanguages[$((iLang+2))]}"
          iLang+=3;;
        productiveDay)
          #filter0="* ${productivityDay[0]}"
          #filter0="${productivityDay[1]}"
          #filter0="${productivityDay[2]}"
          filter0="* ${productivityDay[$iDay]}"
          filter1="${productivityDay[$((iDay+1))]}"
          ## add commit or commits according to counted num
          [[ "$filter1" == 1 ]] && filter1="$filter1 commit"                  \
            || filter1="$filter1 commits"
          filter2="${productivityDay[$((iDay+2))]}"
          iDay+=3;;
        productiveTime)
          filter0="* ${productivityDaytime[$iTime]}"
          filter1="${productivityDaytime[$((iTime+1))]}"
          [[ "$filter1" == 1 ]] && filter1="$filter1 commit"                  \
            || filter1="$filter1 commits"
          filter2="${productivityDaytime[$((iTime+2))]}"
          iTime+=3;;



      esac
      ##DEBUG:
      #echo "0: $filter0 1: $filter1 2: $filter2"

      filterGithubStart+=( ["${githubComment}$i"]="$filter0" )
      filterGithubMiddle+=( ["${githubComment}$i"]="$filter1" )
      filterGithubEnd+=( ["${githubComment}$i"]="$filter2" )
      ##SHIT TO WORK WITH:
      #



    done

    ## inner index loop 2 for keywords that require individual processing: own filter/fetch function
    ## TEMPORARILY DISABLED
#    for ((i = 0; i < $iMax; i++)); do
#      filterGithubStart+=( ["${githubComment}$i"]="${topLanguages[$x]}" )
##      filterGithubMiddle+=( ["${githubComment}$i"]="${topLanguages[$y]}" )
#      filterGithubEnd+=( ["${githubComment}$i"]="${topLanguages[$z]}" )
#      x+=3; y+=3; z+=3
#    done
  done
  _writeGithubTemplate
}
_OLDfilterGithubData() {
  local -A filterGithubName; local -A filterGithubTimestamp
  local -A filterGithubDescription; local -A filterGithubTitle
  local -A filterGithubCompany; local -A filterGithubPercentage
  local -A filterGithubStart; local -A filterGithubMiddle
  local -A filterGithubEnd
  local owner; local urlTitle; local urlName; local isoSec
  local -a productivityDaytime; local -a productivityDay
  local -a topLanguages; local -a filter
  ## fetch&filter directly from filter functions
  topLanguages=( $(_filterGithubTopLanguages) )
  IFS=';' productivityDaytime=( $(_filterGithubProductiveTime) )
  IFS=';' productivityDay=( $(_filterGithubProductiveDay) )

  for githubComment in "${githubComments[@]}"; do
    for ((i = 0; i < 7; i++)); do
      case "$githubComment" in
        projectsOwn|projectsAll) filter=(".data.user.repositories.edges[$i]" ".node")
          [[ "$(jq -r "${filter[0]} | ${filter[1]}.name" <<< "${fetchGithubData["$githubComment"]}")" == $user ]] && continue
          [[ "$(jq -r "${filter[0]} | ${filter[1]}.name" <<< "${fetchGithubData["$githubComment"]}")" == zet ]] && continue
          owner="$(jq -r "${filter[0]} | ${filter[1]}.owner.login" <<< "${fetchGithubData["$githubComment"]}")"
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.name" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[$owner/${filterGithubName["${githubComment}$i"]}]($urlName)"
          filterGithubDescription+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.pushedAt" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        projectsCount) filter=(".data.user.publicRepositories.totalCount" ".data.user.privateRepositories.totalCount")
          [[ $i == 2 ]] && break
          filterGithubStart+=( ["${githubComment}$i"]="$(jq -r "${filter[$i]}" <<< "${fetchGithubData["$githubComment"]}")" );;
          #echo "${filterGithubStart["${githubComment}$i"]}"
        hire) filterGithubStart+=( ["${githubComment}$i"]="$(jq -r .data.viewer.isHireable <<< "$userData")" );;
        pullRequests) filter=(".data.search.edges[$i]" ".node")
          [[ $i == 5 ]] && break
          urlTitle="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.repository.url" <<< "${fetchGithubData["$githubComment"]}")"
          owner="$(jq -r "${filter[0]} | ${filter[1]}.repository.owner.login" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.repository.name" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[$owner/${filterGithubName["${githubComment}$i"]}]($urlName)"
          filterGithubTitle+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.title" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTitle["${githubComment}$i"]="[${filterGithubTitle["${githubComment}$i"]}]($urlTitle)"
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.mergedAt" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        zet) filter=(".data.repository.refs.edges[$i]" ".node.target" ".node.name" )
          [[ $i == 5 ]] && break
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.treeUrl" <<< "${fetchGithubData["$githubComment"]}")"
          isoSec="$(jq -r "${filter[0]} | ${filter[2]}" <<< "${fetchGithubData["$githubComment"]}")"
          [[ $i == 0 ]] && repoName="$(jq -r ".data.repository.name" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="[$user/$repoName]($urlName/$isoSec)" )
          filterGithubTitle+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.message" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.committedDate" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        forks) filter=(".data.user.repositories.edges[$i]" ".node")
          [[ $i == 5 ]] && break
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.name" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[$user/${filterGithubName["${githubComment}$i"]}]($urlName)"
          filterGithubDescription+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")" )
          ## check if it actually finds data to assign to array, if not
          ## skip to next element (technically a break would also work because items are listed in an order)
          [[ "${filterGithubDescription["${githubComment}$i"]}" == "null" ]] && continue
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        stars) filter=(".data.user.starredRepositories.edges[$i]" ".node" ".starredAt")
          [[ $i == 5 ]] && break
          owner="$(jq -r "${filter[0]} | ${filter[1]}.owner.login" <<< "${fetchGithubData["$githubComment"]}")"
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.name" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[$owner/${filterGithubName["${githubComment}$i"]}]($urlName)"
          filterGithubDescription+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[2]}" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        gists) filter=(".data.user.gists.edges[$i]" ".node")
          [[ $i == 5 ]] && break
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.files[0].name" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[$user/${filterGithubName["${githubComment}$i"]}]($urlName)"
          filterGithubDescription+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        followers) filter=(".data.user.followers.edges[$i]" ".node")
          [[ $i == 5 ]] && break
          urlFollower="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[${filterGithubName["${githubComment}$i"]}]($urlFollower)"
          filterGithubCompany+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.company" <<< "${fetchGithubData["$githubComment"]}")" );;
        sponsors) filter=(".data.user.sponsorshipsAsMaintainer.nodes[$i]" ".sponsorEntity" ".createdAt")
          [[ $i == 5 ]] && break
          urlName="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          filterGithubName+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubName["${githubComment}$i"]="[${filterGithubName["${githubComment}$i"]}]($urlName)"
          filterGithubTimestamp+=( ["${githubComment}$i"]="$(jq -r "${filter[0]} | ${filter[2]}" <<< "${fetchGithubData["$githubComment"]}")" )
          filterGithubTimestamp["${githubComment}$i"]="$(_createGithubTimeAgo ${filterGithubTimestamp["${githubComment}$i"]})";;
        productiveDay)
          [[ $i == 0 ]] && local -i x=0 && local -i y=1 && local -i z=2
          filterGithubStart+=( ["${githubComment}$i"]="${productivityDay[$x]}" )
          ##FIXME commits writing it here would mean if a day like Monday
          #has only 1 commit it still reads "Monday 1 commits"
          # change it in the _filterGithubProductiveTime with a logic
          # that has different text for 1 commit or else commits
          filterGithubMiddle+=( ["${githubComment}$i"]="${productivityDay[$y]} commits" )
          filterGithubEnd+=( ["${githubComment}$i"]="${productivityDay[$z]}" )
          x+=3; y+=3; z+=3;;
        productiveTime) [[ $i == 4 ]] && break
          [[ $i == 0 ]] && local -i x=0 && local -i y=1 && local -i z=2
          filterGithubStart+=( ["${githubComment}$i"]="${productivityDaytime[$x]}" )
          ##FIXME same issue as ProductiveDay
          filterGithubMiddle+=( ["${githubComment}$i"]="${productivityDaytime[$y]} commits" )
          filterGithubEnd+=( ["${githubComment}$i"]="${productivityDaytime[$z]}" )
          x+=3; y+=3; z+=3;;
      esac
    done
  done
########################### new filter system ##########################

  _writeGithubTemplate
}
_createGithubMarkdownBlock() {

  ##TODO make this into a case and have languagesCountTotal be a variable that changes
  #the amount of loops needed. Remove the old case that creates
  #markdownBLock as you can directly printf the variables without it.
  #have the `printf "format" "variables"` The variables should remain the
  #same only have 3 if they don't match semantically it's not too much of
  #a deal but have the "format" stored in a variable as it changes from
  #github comment to comment
  #
  local commentArg="$1"
  ## It looks like the empty check is not needed with printf
  #local -i empty=0
  local space0=0; local space1=0; local space2=0
  for ((i = 0; i < ${iMax[$commentArg]}; i++)); do
    ## For the ones that need spaces:
    #[[ $i == 0 ]] && { space0=xx; space1=xx; space2=xx; }

    ## don't 'break'! because zet needs to continue it just skips github
    ## profile and zet repo. Also all other queries that do not find
    ## sufficient data/results (usually 5) get skipped and won't be printed
    ## as empty lines
    [[ -n "${filterGithubStart["${commentArg}$i"]}" ]] || continue
    case "$commentArg" in
      projectsOwn|projectsAll)
        ## It looks like the empty check is not needed with printf
        #[[ -n "${filterGithubStart["${commentArg}$i"]}" ]] || { empty+=1; continue; }
        #[[ $i == 4 || $i == 5 ]] && [[ $empty == 2 ]] && break
        ;;
      languages) space0=20; space1=20;;
      productiveDay) space0=20; space1=20;;
      productiveTime) space0=22; space1=20;;
      #projectsCount) ;;
    esac
    ## generic print statement:
    printf "%-*s %-*s %-*s\n" $space0 "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}"
  done
}
##INTEGRATE THIS:
#  elif [[ "$commentArg" == projectsCount ]]; then
#    for ((i = 0; i < 2; i++)); do
#      if [[ $i -eq 0 ]]; then
#        [[ "${filterGithubStart["${commentArg}$i"]}" -eq 1 ]]                 \
#          && printf "* 💾 %s Public Repository\n" "${filterGithubStart["${commentArg}$i"]}" \
#          || printf "* 💾 %s Public Repositories\n" "${filterGithubStart["${commentArg}$i"]}"
#      else
#        [[ "${filterGithubStart["${commentArg}$i"]}" -eq 1 ]]                 \
#          && printf "* 💾 %s Private Repository\n" "${filterGithubStart["${commentArg}$i"]}" \
#          || printf "* 💾 %s Private Repositories\n" "${filterGithubStart["${commentArg}$i"]}"
#      fi
#    done




################################## old #################################
_OLDcreateGithubMarkdownBlock() {
  local commentArg="$1"
  local markdownBlock
  local -i empty=0
  for ((i = 0; i < 7; i++)); do
    case "$commentArg" in
      projectsOwn|projectsAll) ## if empty because either name is zet, or $user skip current iteration
        [[ -n "${filterGithubName["${commentArg}$i"]}" ]] && empty+=1 || continue
        markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - ${filterGithubDescription["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
        ## make sure in total only 5 lines get created, as soon as reached
        ## break out of loop
        [[ $i == 4 || $i == 5 ]] && [[ $empty == 5 ]] && break;;
        pullRequests) markdownBlock+="* ${filterGithubTitle["${commentArg}$i"]} on ${filterGithubName["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
          [[ $i == 4 ]] && break;;
        zet)  [[ -n "${filterGithubName["${commentArg}$i"]}" ]] || continue
          markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - ${filterGithubTitle["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
          ;;

          #[[ $i == 4 ]] && break;;
        forks) [[ "${filterGithubDescription["${commentArg}$i"]}" == "null" ]] && break
          markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - ${filterGithubDescription["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
          [[ $i == 4 ]] && break;;
        #  ;;
        followers) [[ "${filterGithubCompany["${commentArg}$i"]}" == null ]] && \
          markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - 💼 Unknown\n" || \
          markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - 💼 ${filterGithubCompany["${commentArg}$i"]}\n"
          [[ $i == 4 ]] && break;;
        stars)
        markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - ${filterGithubDescription["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
          [[ $i == 4 ]] && break;;
        gists)
        markdownBlock+="* ${filterGithubName["${commentArg}$i"]} - ${filterGithubDescription["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
          [[ $i == 4 ]] && break;;
        sponsors)
        markdownBlock+="* ${filterGithubName["${commentArg}$i"]} (${filterGithubTimestamp["${commentArg}$i"]})\n"
          [[ $i == 4 ]] && break;;
        #productiveDay) ;;
        ##stats) ;;

    esac
  done

  if [[ "$commentArg" == productiveTime ]]; then
    space1=20; space2=20
    for ((i = 0; i < 4; i++)); do
      #[[ $i == 3 ]] && space1=22
      #echo "$space1 $space2"
      ##FIXME here the first placeholder needs 22, so far others only
      #needed 20, i gotta make a third variable to make it flexible
      printf "* %-22s %-*s %-*s\n" "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}"
      #printf "* %s %${space1}s %${space2}s\n" "${filterGithubStart["${commentArg}$i"]}" "${filterGithubMiddle["${commentArg}$i"]}" "${filterGithubEnd["${commentArg}$i"]}"
    done
  elif [[ "$commentArg" == languages ]]; then
    for ((i = 0; i < ${topLanguages[0]}; i++)); do
      space1=20; space2=20
      ## not aligned:
      #printf "* %s %${space1}s %${space2}s\n" "${filterGithubStart["${commentArg}$i"]}" "${filterGithubMiddle["${commentArg}$i"]}" "${filterGithubEnd["${commentArg}$i"]}"
      ## left aligned
      printf "* %-20s %-*s %-*s\n" "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}"
      ## right aligned:
      #printf "* %20s %*s %*s\n" "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}"
    done

  elif [[ "$commentArg" == projectsCount ]]; then
    for ((i = 0; i < 2; i++)); do
      if [[ $i -eq 0 ]]; then
        [[ "${filterGithubStart["${commentArg}$i"]}" -eq 1 ]]                 \
          && printf "* 💾 %s Public Repository\n" "${filterGithubStart["${commentArg}$i"]}" \
          || printf "* 💾 %s Public Repositories\n" "${filterGithubStart["${commentArg}$i"]}"
      else
        [[ "${filterGithubStart["${commentArg}$i"]}" -eq 1 ]]                 \
          && printf "* 💾 %s Private Repository\n" "${filterGithubStart["${commentArg}$i"]}" \
          || printf "* 💾 %s Private Repositories\n" "${filterGithubStart["${commentArg}$i"]}"
      fi
    done

  elif [[ "$commentArg" == productiveDay ]]; then
    space1=20; space2=20
    for ((i = 0; i < 7; i++)); do
      #printf "* %s %${space1}s %${space2}s\n" "${filterGithubStart["${commentArg}$i"]}" "${filterGithubMiddle["${commentArg}$i"]}" "${filterGithubEnd["${commentArg}$i"]}"
      printf "* %-20s %-*s %-*s\n" "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}"
    done

  elif [[ "$commentArg" == hire ]]; then
    for ((i = 0; i < 1; i++)); do
      [[ "${filterGithubStart["${commentArg}$i"]}" == true ]]                 \
        && printf "> 💼 Open for hire now"                                    \
        || printf "> 🚫 Not available for hire"
    done
  else
    printf "%s" "$markdownBlock"
  fi
}

_writeGithubTemplate() {
  ## Currently there are no plans of adding _createGithubHtmlBlock(),
  ## because in my current README.md markdown works already.
  #local callFunction
  #if [[ "$flag" == "-H" ]]; then
  #  callFunction="_createGithubHtmlBlock"
  #else
  #  callFunction="_createGithubMarkdownBlock"
  #fi
  #
  #_createGithubMarkdownBlock productiveTime
  for githubComment in "${githubComments[@]}"; do
    #content="$($callFunction $githubComment)"
    #_createGithubMarkdownBlock $githubComment
    content="$(_createGithubMarkdownBlock $githubComment)"
    perl -i -0777pe "s@<!--$service-$githubComment-start-->\s*<!--$service-$githubComment-end-->@<!--$service-$githubComment-start-->\n${content}\n  <!--$service-$githubComment-end-->@s" "$template"
  done
  _writeReadme github
}
_createGithubTimeAgo() {
  local timestamp="$1"
  local pushedTimeSec="$(date -d "$timestamp" +%s)"
  local currentTimeSec=$(date -u +%s)
  local deltaTimeDays="$(((currentTimeSec - pushedTimeSec) / 86400))"
  case $deltaTimeDays in
    0) deltaTimeHours="$(((currentTimeSec - pushedTimeSec) / 3600))"
      echo "$deltaTimeHours hours ago";;
    1) echo "$deltaTimeDays day ago";;
    [2-7]) echo "$deltaTimeDays days ago";;
    [8-9]|1[0-4]) echo "1 week ago";;
    1[5-9]|2[0-1]) echo "2 weeks ago";;
    2[2-8]) echo "3 weeks ago";;
    29|3[0-9]|4[0-9]) echo "1 month ago";;
    ##TODO if more than 12 months make it 1 year, if more than 24
    #months make it 2 years and so on...
    *) ## round months up if remainder is higher than half a months days
      if [[ "$deltaTimeDays%30" -ge 15 ]]; then
        echo "$(((deltaTimeDays/30) + 1)) months ago"
      else
        echo "$((deltaTimeDays/30)) months ago"
      fi;;
  esac
}
_filterGithubTopLanguages() {
  ##filter languages:
  ##TODO many of those top lang related code should be outsourced into functions
  ## reposCountTotal gets the total amount of found repositories
  local -i reposCountTotal="$(jq -r ".data.search.repositoryCount" <<< "${fetchGithubData[languages]}")"
  local -A languagesNameCount
  local -i languagesCountTotal
  local -a languagesArray
  local percentageName #cannot be an integer type, bash doesn't support floats!
  for ((i = 0; i < $reposCountTotal; i++)); do
    filter=(".data.search.edges[$i]" ".node")
    languageName="$(jq -r "${filter[0]} | ${filter[1]}.primaryLanguage.name" <<< "${fetchGithubData[languages]}")"
    #can't skip null need that to calculate percentage correctly
    #[[ $language == null ]] && continue
    grep -q "$languageName" <<< "${!languagesNameCount[@]}"                    \
      && languagesNameCount[$languageName]=$((languagesNameCount[$languageName] + 1)) \
      || { languagesNameCount+=( [$languageName]=1 ); languagesCountTotal+=1; }
  done
  ## if 'null' language exists, substract all counted null appearances, also remove 1 from languagesCountTotal
  if [[ -n ${languagesNameCount[null]} ]]; then
    languagesCountTotal=$((languagesCountTotal-1))
    reposCountTotal=$((reposCountTotal - ${languagesNameCount[null]}))
  fi

  ##loop over keys:  keys = languageNames, values = counted number of language
  #echo "$languagesCountTotal"

  languagesArray+=( "${languagesCountTotal}" )
  for languageName in "${!languagesNameCount[@]}"; do
    ## skip loop if null
    [[ $languageName == null ]] && continue
    percentageName="$(awk '{print sprintf("%.2f", $1/$2*100)}' <<< "${languagesNameCount[$languageName]} $reposCountTotal")%"
    #percentageName=$(perl -e 'printf "%.2f\n", '"(${languagesNameCount[$languageName]} / $reposCountTotal)*100"' ')
    languagesArray+=( "${languageName}" "${languagesNameCount[$languageName]}" "${percentageName}" )
  done
  echo "${languagesArray[*]}"
}
_filterGithubProductiveDay() {
  local -A commitCount
  local -A percentage
  local -a weekdays=( "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday" )

  ## count commits per weekday
  while read line; do
    if [[ $line =~ committedDate.* ]]; then
      datestamp="$(echo "$line" | grep -o ':.*Z' | sed 's|^...||')"
      weekday="$(date -d "$datestamp" +%A)"
      commitCount[$weekday]=$((commitCount[$weekday]+1))
    fi
  done < <(echo "${fetchGithubData[productiveDay]}")

  for weekday in "${!commitCount[@]}"; do
    echo "Commits on $weekday: ${commitCount[$weekday]}"
  done

  ## TODO: get total commit count
  totalCommitCount=""

  ## calculate percentage of counted weekdays
  for weekday in "${weekdays[@]}"; do
    if [[ -z ${commitCount[$weekday]} ]]; then
      ${commitCount[$weekday]}=0
      ${percentage[$weekday]}=0.00%
    else
      ${percentage[$weekday]}="$(printf "%.2f\n" $(bc -l <<< "(${commitCount[$weekday]} / $totalCommitCount) * 100"))%"
    fi
  done

  echo "${weekdays[*]} ${commitCount[*]} ${percentage[*]}"
}
## TODO create  new _filterGithubProductiveTime() function

_OLDfilterGithubProductiveDay() {
  local -i xRepoMax="$(jq -r ".data.user.repositories.totalCount" <<< "${fetchGithubData[productiveDay]}")"
  local -i yCommitMax; local -i totalCommitCount
  local -a filter
  local -i mondayCommitCount; local -i tuesdayCommitCount
  local -i wednesdayCommitCount; local -i thursdayCommitCount
  local -i fridayCommitCount; local -i saturdayCommitCount
  local -i sundayCommitCount
  local mondayPercentage; local tuesdayPercentage; local wednesdayPercentage
  local thursdayPercentage; local fridayPercentage; local saturdayPercentage
  local sundayPercentage
  for ((x = 0; x < $xRepoMax; x++)); do
    yCommitMax="$(jq -r ".data.user.repositories.edges[$x] | .node.defaultBranchRef.target.history.totalCount" <<< "${fetchGithubData[productiveDay]}")"
    [[ "$yCommitMax" == null ]] || totalCommitCount+="$yCommitMax"
    for ((y = 0; y < $yCommitMax; y++)); do
      filter=(".data.user.repositories.edges[$x]" ".node.defaultBranchRef.target.history.edges[$y]" ".node.committedDate")
      datestamp="$(jq -r "${filter[0]} | ${filter[1]} | ${filter[2]}" <<< "${fetchGithubData[productiveDay]}")"
      #echo $datestamp
      datestamp="$(date -d "$datestamp" +%A)"
      case "$datestamp" in
        Monday) mondayCommitCount+=1;;
        Tuesday) tuesdayCommitCount+=1;;
        Wednesday) wednesdayCommitCount+=1;;
        Thursday) thursdayCommitCount+=1;;
        Friday) fridayCommitCount+=1;;
        Saturday) saturdayCommitCount+=1;;
        Sunday) sundayCommitCount+=1;;
      esac
    done
  done
  if [[ -z $mondayCommitCount ]]; then
    mondayCommitCount=0
    mondayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    mondayPercentage="$(printf "%.2f\n" $(bc -l <<< "($mondayCommitCount / $totalCommitCount) * 100"))%"
  fi

  if [[ -z $tuesdayCommitCount ]]; then
    tuesdayCommitCount=0
    tuesdayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    tuesdayPercentage="$(printf "%.2f\n" $(bc -l <<< "($tuesdayCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $wednesdayCommitCount ]]; then
    wednesdayCommitCount=0
    wednesdayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    wednesdayPercentage="$(printf "%.2f\n" $(bc -l <<< "($wednesdayCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $thursdayCommitCount ]]; then
    thursdayCommitCount=0
    thursdayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    thursdayPercentage="$(printf "%.2f\n" $(bc -l <<< "($thursdayCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $fridayCommitCount ]]; then
    fridayCommitCount=0
    fridayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    fridayPercentage="$(printf "%.2f\n" $(bc -l <<< "($fridayCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $saturdayCommitCount ]]; then
    saturdayCommitCount=0
    saturdayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    saturdayPercentage="$(printf "%.2f\n" $(bc -l <<< "($saturdayCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $sundayCommitCount ]]; then
    sundayCommitCount=0
    sundayPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    sundayPercentage="$(printf "%.2f\n" $(bc -l <<< "($sundayCommitCount / $totalCommitCount) * 100"))%"
  fi

  echo "Monday;$mondayCommitCount;$mondayPercentage;Tuesday;$tuesdayCommitCount;$tuesdayPercentage;Wednesday;$wednesdayCommitCount;$wednesdayPercentage;Thursday;$thursdayCommitCount;$thursdayPercentage;Friday;$fridayCommitCount;$fridayPercentage;Saturday;$saturdayCommitCount;$saturdayPercentage;Sunday;$sundayCommitCount;$sundayPercentage"
}
#_filterGithubProductiveDaytime() {
_filterGithubProductiveTime() {
  ## calculate most productive daytime of current month measured by
  ## amount of commits
  local -i xRepoMax="$(jq -r ".data.user.repositories.totalCount" <<< "${fetchGithubData[productiveTime]}")"
  local -i yCommitMax
  local -i totalCommitCount
  local -a filter; local datestamp; local timestamp
  local -i hours; local -i minutes
  local -i morningCommitCount; local -i daytimeCommitCount
  local -i eveningCommitCount; local -i nightCommitCount
  local morningPercentage; local daytimePercentage
  local eveningPercentage; local nightPercentage
  local morning="🌅 Morning"; local daytime="🌞 Daytime"
  local evening="🌇 Evening"; local night="🌃 Night"

  for ((x = 0; x < $xRepoMax; x++)); do
    yCommitMax="$(jq -r ".data.user.repositories.edges[$x] | .node.defaultBranchRef.target.history.totalCount" <<< "${fetchGithubData[productiveTime]}")"
    #totalCommitCount+="$yCommitMax"
    [[ "$yCommitMax" == null ]] || totalCommitCount+="$yCommitMax"
    for ((y = 0; y < $yCommitMax; y++)); do
      filter=(".data.user.repositories.edges[$x]" ".node.defaultBranchRef.target.history.edges[$y]" ".node.committedDate")
      datestamp="$(jq -r "${filter[0]} | ${filter[1]} | ${filter[2]}" <<< "${fetchGithubData[productiveTime]}")"
      echo $datestamp

      ## truncate date from datestamp, only time needed
      timestamp="${datestamp##*T}"
      ## get hours
      hours="$(cut -d: -f1 <<< $timestamp)"
      ## get minutes, sed needed to rm first 0 for minutes 01-09 otherwise remainder errors, minute 00 is fine just one 0 gets removed
      minutes="$(cut -d: -f2 <<< $timestamp | sed 's|^0||')"
      #echo $timestamp
      #echo $hours-$minutes
      if [[ "$minutes%60" -ge 30 ]]; then
        hours+=1
        [[ $hours -eq 24 ]] && hours=0
      fi
      #echo $hours-$minutes
      case $hours in
        [0-5]) nightCommitCount+=1;;
        [6-9]|1[0-1]) morningCommitCount+=1;;
        1[2-7]) daytimeCommitCount+=1;;
        1[8-9]|2[0-3]) eveningCommitCount+=1;;
      esac
    done
  done
  ## if no commits found make it 0
  if [[ -z $morningCommitCount ]]; then
    morningCommitCount=0
    morningPercentage=0.00%
  else
    ##calculate percentage reraltive to totalCommitCount
    morningPercentage="$(printf "%.2f\n" $(bc -l <<< "($morningCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $daytimeCommitCount ]]; then
    daytimeCommitCount=0
    daytimePercentage=0.00%
  else
    daytimePercentage="$(printf "%.2f\n" $(bc -l <<< "($daytimeCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $eveningCommitCount ]]; then
    eveningCommitCount=0
    eveningPercentage=0.00%
  else
    eveningPercentage="$(printf "%.2f\n" $(bc -l <<< "($eveningCommitCount / $totalCommitCount) * 100"))%"
  fi
  if [[ -z $nightCommitCount ]]; then
    nightCommitCount=0
    nightPercentage=0.00%
  else
    nightPercentage="$(printf "%.2f\n" $(bc -l <<< "($nightCommitCount / $totalCommitCount) * 100"))%"
  fi

  echo "$morning;$morningCommitCount;$morningPercentage;$daytime;$daytimeCommitCount;$daytimePercentage;$evening;$eveningCommitCount;$eveningPercentage;$night;$nightCommitCount;$nightPercentage"
}

############################# wakatime func ############################
_fetchWakaData() {
  local fetchWakaData=$(curl https://wakatime.com/api/v1/users/current/stats/last_7_days?api_key="$wakaKey" | jq '.')
  _filterWakaData
}
_filterWakaData() {
  ##  Declare local variables: strings, integers and arrays
  local -A filterWakaName=()
  local -A filterWakaPercent=()
  local -A filterWakaText=()
  local -A filterWakaLines=()
  local filterWakaTimezone="$(jq -r ".data.timezone" <<< "$fetchWakaData")"
  ## Create associative arrays with data, use comment as outer loop and
  ## line number as inner loop. Uses line number  as max. index to
  ## iterate over. The same jq filter needs to be used again, mainly
  ## because when we retrive data we don't know how many objects are
  ## coming in.
  for wakaComment in "${wakaComments[@]}"; do
    ## check if wakaComment is timezone if so break out of the loop
    [[ "$wakaComment" != timezone ]] || break
    ## Get the total number of lines for each data element and store it
    ## in associative array. Since each element is on a own line the line
    ## number represent the number of elements for each comment.
    filterWakaLines+=( ["$wakaComment"NameLines]="$(jq -r ".data.$wakaComment | .[] | .name" <<< "$fetchWakaData" | wc -l)" )
    filterWakaLines+=( ["$wakaComment"PercentLines]="$(jq -r ".data.$wakaComment | .[] | .percent" <<< "$fetchWakaData" | wc -l)" )
    filterWakaLines+=( ["$wakaComment"TextLines]="$(jq -r ".data.$wakaComment | .[] | .text" <<< "$fetchWakaData" | wc -l)" )
    ## test if lines per wakaComment are the same on each filtered variable, or continue with next comment
    [[ ${filterWakaLines["$wakaComment"NameLines]} -eq ${filterWakaLines["$wakaComment"PercentLines]} && \
      ${filterWakaLines["$wakaComment"NameLines]} -eq ${filterWakaLines["$wakaComment"TextLines]} ]] || break
    ## Create associavtive array from data: Name, Percentage, Timestamp
    ## loops over max. elements found per comment
    for ((i = 0; i < "${filterWakaLines["${wakaComment}NameLines"]}"; i++)); do
      filterWakaName+=( ["${wakaComment}Name$i"]="$(jq -r ".data.$wakaComment | .[$i] | .name" <<< "$fetchWakaData")" )
      filterWakaPercent+=( ["${wakaComment}Percent$i"]="$(jq -r ".data.$wakaComment | .[$i] | .percent" <<< "$fetchWakaData")" )
      filterWakaText+=( ["${wakaComment}Text$i"]="$(jq -r ".data.$wakaComment | .[$i] | .text" <<< "$fetchWakaData")" )
    done
  done
_writeWakaTemplate
}
_createWakaMarkdownBlock() {
  ## No title, user should be able to pick own title
  local commentArg="$1"
  ## activate this and test if it works wit initiated variable `local markdownBlock`
  if [[ "$commentArg" == timezone ]]; then
    markdownBlock+="$filterWakaTimezone"
    printf "%s" "$markdownBlock" && return 0
  fi
  for ((i = 0 ; i < "${filterWakaLines["${commentArg}NameLines"]}" ; i++)); do
    ##FIXME The last time it runs you don't want \n
    markdownBlock+="${filterWakaName["${commentArg}Name$i"]} ${filterWakaText["${commentArg}Text$i"]} ${filterWakaPercent["${commentArg}Percent$i"]}%  \n"
  done
  printf "%s" "$markdownBlock"
}
_createWakaHtmlBlock() {
  ##FIXME DRY maybe it's possible to only have one function
  ## _createHtmlBlock which works for all services. And uses code it has
  ## in common with other services.
  local commentArg="$1"
  local languagesHtmlBlock='<h4>💬 Languages:</h4>'
  local editorsHtmlBlock='<h4>📝 Editors:</h4>'
  local operating_systemsHtmlBlock='<h4>💻 Operating Systems:</h4>'
  local projectsHtmlBlock='<h4>🌱 Projects:</h4>'
  local timezoneHtmlBlock='<h4>🕐 Timezone:</h4>'
  ## Indirect reference to assign variables in loop.
  local -n htmlBlock=${commentArg}HtmlBlock
  if [[ "$commentArg" == timezone ]]; then
    htmlBlock+="\n<span>$filterWakaTimezone</span>"
    printf "%s" "$htmlBlock" && return 0
  fi
  for ((i = 0 ; i < "${filterWakaLines["${commentArg}NameLines"]}" ; i++)); do
    htmlBlock+="\n<span>${filterWakaName["${commentArg}Name$i"]}</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>${filterWakaText["${commentArg}Text$i"]}</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>${filterWakaPercent["${commentArg}Percent$i"]}%</span>"
  done
  printf "%s" "$htmlBlock"
}
_writeWakaTemplate() {
  ##FIXME DRY maybe I can create a general _printHtmlBlocks function for
  #all services and depending on service different parts of it execute.
  #case "$service" in
  #  wakatime) echo waka;;
  #  github) echo github;;
  #esac
  local callFunction
  if [[ "$flag" == "-H" ]]; then
    callFunction="_createWakaHtmlBlock"
  else
    callFunction="_createWakaMarkdownBlock"
  fi
  for wakaComment in "${wakaComments[@]}"; do
    content="$($callFunction $wakaComment)"
    perl -i -0777pe "s|<!--$service-$wakaComment-start-->\s*<!--$service-$wakaComment-end-->|<!--$service-$wakaComment-start-->\n${content}\n  <!--$service-$wakaComment-end-->|s" "$template"
  done
  _writeReadme wakatime
}
########################### general func end ###########################
_writeReadme() {
  ## Update new API data/content into readme
  cat "$template" > "$readme"
  [[ "$1" == wakatime ]] && _cleanUpFiles wakatime
  [[ "$1" == github ]] && _cleanUpFiles github
}
_cleanUpFiles() {
  [[ "$1" == wakatime ]] && local -a comments=("${wakaComments[@]}")
  [[ "$1" == github ]] && local -a comments=("${githubComments[@]}")
  for comment in "${comments[@]}"; do
    ## remove comments from README.md
    sed -i "/<!--$service-$comment-start-->/d" "$readme"
    sed -i "/<!--$service-$comment-end-->/d" "$readme"
    ## remove content between comments from template
    perl -i -0777pe "s/<!--$service-$comment-start-->.*<!--$service-$comment-end-->/<!--$service-$comment-start-->\n  <!--$service-$comment-end-->/s" "$template"
  done
}
_main

exit



################################# stuff ################################
## Remember: Variables and sed are a bit tricky. Don't quote variables that have spaces!
#https://stackoverflow.com/questions/49461777/sed-with-variables-and-spaces
##TODO add a percentage/progress bar to the html block to visualize the
##percentage

## User Instructions:
## * login to wakatime.com and create an account also copy the api key
## when you are logged in. Go to github.com to your github profile repo
## and click on 'Settings' 'Secrets and variables' 'Actions' and add
## go to github profile repo on website go to "settings" "secrests" add
## "PERSONAL_WAKATIME_KEY" with your copied waka API key as value
## * click on your profile picture in top right 'Settigngs' 'Developer
## settings' 'Personal access tokens' 'Tokens (classic)' and create a
## token with this scope:  .... Also safe the token somewhere safe github
## won't show it to you after creation, copy the token and
## add another 'secret' to your github.com profile repo. Name it
## 'PERSONAL_GITHUB_TOKEN' and paste the your token in as the value.
## * add the templates/templateReadme.md.tpl to your profile repo and
## write your github.com profile page from this file, never edit the
## README.md as it will get overwritten. Also add the html comments
## wherever you wanted automated information to be placed.
## * add the .github/workflows/action.yml file and paste the information
## from this repo in there to create a working workflow.
