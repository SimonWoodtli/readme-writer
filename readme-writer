#!/usr/bin/bash
## set the personal access token & key to github env. var secret
declare wakaKey="$PERSONAL_WAKATIME_KEY"
declare githubKey="$PERSONAL_GITHUB_TOKEN"
#source api-keys #Temporary for testing the script
# dependencies: bash, sed, jq, printf, perl
declare -A flags
## check flags
while getopts 'cmht' OPTION; do
  case "$OPTION" in
    c) flags[c]="sinceAccCreation";;
    m) flags[m]="sinceLastMonth";;
    h) flags[h]="htmlBlockList";;
    t) flags[t]="markdownBlockTable";;
  esac
done
shift "$(($OPTIND -1))"
declare template="$1"
declare readme="$2"
## Check if template and readme are right format or exit
[[ "$template" == *.tpl ]] || exit 1
[[ "$readme" == *.md ]] || exit 1

########################## general func start ##########################
_main() {
  ## waka
  local -a wakaComments
  IFS=" " read -r -a wakaComments <<< "$(_checkHtmlComments wakatime)"
  local -a services
  echo "start wakatime"
  [[ -z "${wakaComments[*]}" ]] || { services+=("wakatime"); _fetchWakaData; }
  ## github
  echo "start github"
  local -a githubComments
  IFS=" " read -r -a githubComments <<< "$(_checkHtmlComments github)"
  if [[ -n "${githubComments[*]}" ]]; then
    source queries
    local services+=("github")
    ## Get username and id
    local declare userData="$(_queryGithubData _printQueryUser)"
    local declare user="$(jq -r .data.viewer.login <<< "$userData")"
    local declare id="$(jq -r .data.viewer.id <<< "$userData")"
    local declare since
    if [[ -z "${flags[m]}" && -z "${flags[c]}" ]]; then
      since="$(date -u -d "$date -1 year" +"%FT%TZ")"
    fi
    [[ "${flags[m]}" == "sinceLastMonth" ]] && since="$(date -u -d "$date -1 month" +"%FT%TZ")"
    [[ "${flags[c]}" == "sinceAccCreation" ]] && since="$(jq -r .data.viewer.createdAt <<< "$userData")"
    ## difference between waka REST and github graphql, github
    ## requires already a looping over comments, because multiple queries
    ## are needed
    _fetchGithubData
  fi
  _writeReadme
}
_checkHtmlComments() {
  local service="$1"
  local checkCommentStartLine; local checkCommentEndLine
  ## Find all the html comment tags in the readme template and put them
  ## in an array.
  local -a commentsArray
  case "$service" in
    ## keywords/comments are existent in REST API. They are
    ## needed throughout the whole script to filter with jq and so on.
    wakatime) local -a lookupComments=("languages" "editors" "operating_systems" "projects" "timezone");;
    ## since graphql is used here, the keyword could be anything as queries are
    ## needed and filtering with jq works with more generic terms.
    github) local -a lookupComments=("projectsOwn" "projectsAll" "projectsCount" "hire" "pullRequests" "zet" "forks" "stars" "gists" "followers" "sponsors" "languages" "productiveDay" "productiveTime");;
    ## future REST APIs should also be implemented with a keyword that
    ## exists in the received JSON and is represented in the html comment.
  esac
  ## Loop over all possible comments from lookupComments and check if they
  ## can be found in template, if yes add them to wakaComments
  for lookupComment in "${lookupComments[@]}"; do
    checkCommentStartLine="$(grep -n "<!--$service-$lookupComment-start-->" "$template" | cut -c1,3)"
    checkCommentEndLine="$(grep -n "<!--$service-$lookupComment-end-->" "$template" | cut -c1,3)"
    if [[ -n "$checkCommentStartLine" && -n "$checkCommentEndLine" ]]; then
      commentsArray+=("${lookupComment}")
    fi
  done
  echo "${commentsArray[*]}"
}
############################# utility func #############################
_createTimeAgo() {
  local timestamp="$1"
  local pushedTimeSec="$(date -d "$timestamp" +%s)"
  local currentTimeSec="$(date -u +%s)"
  local deltaTimeDays="$(((currentTimeSec - pushedTimeSec) / 86400))"
  case "$deltaTimeDays" in
    0) deltaTimeHours="$(((currentTimeSec - pushedTimeSec) / 3600))"
      echo "$deltaTimeHours hours ago";;
    1) echo "$deltaTimeDays day ago";;
    [2-7]) echo "$deltaTimeDays days ago";;
    [8-9]|1[0-4]) echo "1 week ago";;
    1[5-9]|2[0-1]) echo "2 weeks ago";;
    2[2-8]) echo "3 weeks ago";;
    29|3[0-9]|4[0-9]) echo "1 month ago";;
    ##TODO if more than 12 months make it 1 year, if more than 24
    #months make it 2 years and so on...
    *) ## round months up if remainder is higher than half a months days
      if [[ "$deltaTimeDays%30" -ge 15 ]]; then
        echo "$(((deltaTimeDays/30) + 1)) months ago"
      else
        echo "$((deltaTimeDays/30)) months ago"
      fi;;
  esac
}
_createStatusBar() {
  ## status bar total width/blocks
  local -i width=25; local -i empty
  local percent="$1"
  local filled; local blockFilled; local blockEmpty
  ## calc with correct rounding amount of filled and empty blocks
  filled="$(bc -l <<< "($width * $percent) / 100")"
  #if (( "$(echo "$filled - $(printf '%.0f' "$filled") >= 0.5" | bc -l)" )); then
  if (( "$(bc -l <<< "$filled - $(printf '%.0f' "$filled") >= 0.5")" )); then
    filled="$(bc -l <<< "$(printf '%.0f' "$filled") + 1")"
  else
    filled="$(printf '%.0f' "$filled")"
  fi
  empty=$((width - filled))
  blockFilled="‚ñà"
  blockEmpty="‚ñë"
  ## $filled and $empty need to be +1 because this will print in beteween
  ## num 1-xx blocks and then remove 1-xx but because it's in between it's
  ## one short. Use `seq -s content integer` integer defines how often to
  ## print content sed then removes the numbers
  printf "%s\n" "$(seq -s "$blockFilled" $((filled+1)) | sed 's/[0-9]//g')$(seq -s "$blockEmpty" $((empty+1)) | sed 's/[0-9]//g')"
}
############################## github func #############################
_queryGithubData() {
  ## query: `_queryGithubData _printQueryXXX`, $1 = printQueryXXX func,
  ## stored in 'queries' file
  query="$($1)"
  ## this echo $query without quotes is needed to get query on a single
  ## line, sed is needed to escape any double quotes in the query string
  ## both those things are needed for the curl command to work
  query="$(echo $query | sed 's/"/\\"/g' )"
  curl -s -H 'Content-Type: application/json' \
     -H "Authorization: bearer $githubKey" \
     -d "{ \"query\": \"$query\"}" https://api.github.com/graphql | jq '.'
}
############################# github fetch #############################
_fetchGithubData() {
  ## loop over all queries needed and fetch the different data.
  ## Data that requires more intensive processing is coming from
  ## individual _filterGithubXXX functions that filter and
  ## proccess data on their own. They being called from within
  ## _fetchGithubData and stored in arrays.
  local -A fetchGithubData
  for githubComment in "${githubComments[@]}"; do
    case $githubComment in
      projectsOwn) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposOwn)" );;
      projectsAll) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposAll)" );;
      projectsCount) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryReposTotal)" );;
      pullRequests) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryPullRequests)" );;
      zet) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryZet)" );;
      forks) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryForks)" );;
      stars) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryStars)" );;
      gists) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryGists)" );;
      followers) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQueryFollowers)" );;
      sponsors) fetchGithubData+=( ["$githubComment"]="$(_queryGithubData _printQuerySponsors)" );;
      ## queries which require multiple request because of githubs 100 entries
      ## cap are fetching data via their own functions
      languages) fetchGithubData+=( ["$githubComment"]="$(_fetchGithubLanguagesPages)" );;
      productiveDay) fetchGithubData+=( ["$githubComment"]="$(_fetchGithubProductiveRepoPages)" );;
      productiveTime) ## only request query if productiveDay dit not already do it
        if [[ -z "${fetchGithubData[productiveDay]}" ]]; then
          fetchGithubData+=( ["$githubComment"]="$(_fetchGithubProductiveRepoPages)" )
        else
          fetchGithubData+=( ["$githubComment"]="${fetchGithubData[productiveDay]}" )
        fi;;
    esac
  done
  #echo "${fetchGithubData[languages]}"
  _filterGithubData
}
_fetchGithubLanguagesPages() {
  local response; local data; local hasNextPage; local languageCursor
  # request first query
  response="$(_queryGithubData _printQueryLanguagesFirstPage)"
  ## add first 100 repos page with it's primary language
  data="$response"
  hasNextPage="$(jq '.data.search.pageInfo.hasNextPage' <<< "$response")"
  ## loop over all repo pages and keep adding new repo page data
  while [[ "$hasNextPage" = true ]]; do
    languageCursor="$(jq '.data.search.pageInfo.endCursor' <<< "$response" | tr -d '"')"
    response="$(_queryGithubData _printQueryLanguagesNextPage)"
    data+="$response"
    hasNextPage="$(jq '.data.search.pageInfo.hasNextPage' <<< "$response")"
  done
  echo "$data"
}
_fetchGithubProductiveRepoPages() {
  local responseMain; local data; local repoHasNextPage; local repoCursor
  local -i iMax
  # Call the first query
  responseMain="$(_queryGithubData _printQueryProductivityFirstRepoPage)"
  ## add first repo page with first 100 commits per repo to data
  data="$responseMain"
  repoHasNextPage="$(jq '.data.user.repositories.pageInfo.hasNextPage' <<< "$responseMain")"
  #local -i x=0
  ## set iMax according to whether or not more repo pages available
  [[ "$repoHasNextPage" = true ]] && iMax=2 ||
    iMax=$(jq '.data.user.repositories.totalCount' <<< "$responseMain")
  ## check first repo page, if repos have more than 100 commmits add to data
  data+="$(_fetchGithubProductiveCommitPages)"
  ## outer loop: over all repo pages and add keep adding rest of commits
  while [[ "$repoHasNextPage" = true ]]; do
    #echo index repo x: $x
    repoCursor="$(jq '.data.user.repositories.pageInfo.endCursor' <<< "$responseMain" | tr -d '"')"
    #echo repoCursor: $repoCursor
    ## get new repo page
    responseMain="$(_queryGithubData _printQueryProductivityNextRepoPage)"
    ## add first 100 commits from new repo page to data
    data+="$responseMain"
    ## check if new repo page has more than 100 commits and add to data
    ##FIXME the last repo page has not iMax=100 but would need the
    #remaining repos set as iMax, it works but it's just ugly this way
    data+="$(_fetchGithubProductiveCommitPages)"
    #_filterGithubProductiveDay && [[ $x == 3 ]] && exit
    ## check if more repo pages available
    repoHasNextPage="$(jq '.data.user.repositories.pageInfo.hasNextPage' <<< "$responseMain" | tr -d '"')"
    #echo repoNextpage inside: $repoHasNextPage
    #x+=1
  done
  echo "$data"
}
_fetchGithubProductiveCommitPages() {
  local hasNextPage; local cursor; local response; local dataCommits
  local hasNextPageInside
  ## inner loop: over each repo with more than 100 commits
  for ((i = 0; i < "$iMax"; i++)); do
    hasNextPage="$(jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage" <<< "$responseMain")"
    ## check if another page can is available if so second query is needed
    if [[ "$hasNextPage" = true ]]; then
      #echo index commmits: $i
      cursor="$(jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.endCursor" <<< "$responseMain" | tr -d '"')"
      #echo cursor commit: $cursor
      ## check if _fetchGithubProductiveCommitPages is called first time
      if [[ -z "$repoCursor" ]]; then
        ## Call the next commit page query, without repoCursor set
        response="$(_queryGithubData _printQueryProductivityFirstRepoPageCommitPage)"
      else
        ## Call the next commit page query, with repoCursor set
        response="$(_queryGithubData _printQueryProductivityNextRepoPageNextCommitPage)"
      fi
      ## add second 100 commits to data
      dataCommits+="$response"
      hasNextPageInside="$(jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage" <<< "$response")"
      #echo nextpage inside commit: $hasNextPageInside
    fi
    ## second inner commit loop: check if after the second query there is even more data, if so keep
    ## requesting data until end
    while [ "$hasNextPageInside" = true ]; do
      #echo index commits i: $i
      # Parse the end cursor and has next page values from the response
      cursor="$(jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.endCursor" <<< "$response" | tr -d '"')"
      #echo cursor commit: $cursor
      ## check if _fetchGithubProductiveCommitPages is called first time
      if [[ -z "$repoCursor" ]]; then
        ## Call the next commit page query, without repoCursor set
        response="$(_queryGithubData _printQueryProductivityFirstRepoPageCommitPage)"
      else
        ## Call the next commit page query, with repoCursor set
        response="$(_queryGithubData _printQueryProductivityNextRepoPageNextCommitPage)"
      fi
      ## add third-end batch of 100 commits to data
      dataCommits+="$response"
      hasNextPageInside="$(jq ".data.user.repositories.edges[$i].node.defaultBranchRef.target.history.pageInfo.hasNextPage" <<< "$response")"
      #echo nextpage inside again commit: $hasNextPageInside
    done
  done
  echo "$dataCommits"
}
############################# github filter ############################
_filterGithubData() {
  local -A filterGithubStart; local -A filterGithubMiddle
  local -A filterGithubEnd; local -A iMax
  local -a productivityDaytime; local -a productivityDay
  local -a topLanguages; local -a filter
  local filter0; local filter1; local filter2
  local repoName; local nameWithOwner; local urlRepo; local description
  local datestamp; local repoCount; local hireable; local urlRequest
  local titleRequest; local urlCommit; local isoSec; local commitMsg
  local urlGist; local fileName; local owner; local urlFollower
  local nameFollower; local workplaceFollower; local urlSponsor
  local nameSponsor
  ## loop to set iMax:
  for githubComment in "${githubComments[@]}"; do
    case "$githubComment" in
      projectsOwn|projectsAll) iMax["$githubComment"]=7;;
      projectsCount) iMax["$githubComment"]=2;;
      hire) iMax["$githubComment"]=1;;
      pullRequests|zet|forks|stars|gists|followers|sponsors) iMax["$githubComment"]=5;;
      ## special treatment with pre processing in own functions:
      languages) IFS=';' topLanguages=( $(_filterGithubLanguages) )
        iMax["$githubComment"]=${topLanguages[0]}; local -i iLang=1; local -i x;;
      productiveDay) IFS=';' productivityDay=( $(_filterGithubProductiveDay) )
        iMax["$githubComment"]=7; local -i iDay=0; local -i x;;
      productiveTime) IFS=';' productivityDaytime=( $(_filterGithubProductiveTime) )
        iMax["$githubComment"]=4; local -i iTime=0; local -i x;;
    esac
  done
  ## outer comment loop:
  for githubComment in "${githubComments[@]}"; do
    ## inner index loop 1 for keywords that can be easily processed
    ## DEBUG:
    #echo "$githubComment iMax: ${iMax[$githubComment]}"
    for ((i = 0; i < "${iMax[$githubComment]}"; i++)); do
      case "$githubComment" in
        projectsOwn|projectsAll)
          filter=(".data.user.repositories.edges[$i]" ".node")
          repoName="$(jq -r "${filter[0]} | ${filter[1]}.name" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found. Because User does not
          ## have sufficient repos
          [[ "$repoName" == null ]] && break
          ## skip github profile and zet repo
          [[ "$repoName" == "$user" || "$repoName" == zet ]] && continue
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< "${fetchGithubData["$githubComment"]}")"
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.pushedAt" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
        projectsCount) filter=(".data.user.publicRepositories.totalCount" ".data.user.privateRepositories.totalCount")
          repoCount="$(jq -r "${filter[$i]}" <<< "${fetchGithubData["$githubComment"]}")"
          ## skip inner loop if no data found
          [[ "$repoCount" == null ]] && continue
          filter0="üíæ"
          filter1="$repoCount"
          ## filter2 first element is public second is Private
          if [[ "$i" -eq 0 ]]; then
            [[ "$filter1" == 1 ]] && filter2="Public Repository"              \
              || filter2="Public Repositories"
          else
            [[ "$filter1" == 1 ]] && filter2="Private Repository"             \
              || filter2="Private Repositories"
          fi;;
        hire) filter1=""; filter2=""
          hireable="$(jq -r .data.viewer.isHireable <<< "$userData")"
          [[ "$hireable" == true ]] && filter0="üíº Open for hire now"         \
            || filter0="üö´ Not available for hire" ;;
        pullRequests) filter=(".data.search.edges[$i]" ".node")
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.repository.nameWithOwner" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$nameWithOwner" == null ]] && break
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.repository.url" <<< "${fetchGithubData["$githubComment"]}")"
          urlRequest="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          titleRequest="$(jq -r "${filter[0]} | ${filter[1]}.title" <<< "${fetchGithubData["$githubComment"]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.mergedAt" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$titleRequest]($urlRequest)"
          filter1="on [$nameWithOwner]($urlRepo)"
          filter2="($datestamp)";;
        zet) filter=(".data.repository.refs.edges[$i]" ".node.target" ".node.name" )
          [[ $i -eq 0 ]] && nameWithOwner="$(jq -r ".data.repository.nameWithOwner" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$nameWithOwner" == null ]] && break
          urlCommit="$(jq -r "${filter[0]} | ${filter[1]}.treeUrl" <<< "${fetchGithubData["$githubComment"]}")"
          isoSec="$(jq -r "${filter[0]} | ${filter[2]}" <<< "${fetchGithubData["$githubComment"]}")"
          commitMsg="$(jq -r "${filter[0]} | ${filter[1]}.message" <<< "${fetchGithubData["$githubComment"]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.committedDate" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$nameWithOwner]($urlCommit/$isoSec)"
          filter1="- $commitMsg"
          filter2="($datestamp)";;
        forks) filter=(".data.user.repositories.edges[$i]" ".node")
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$urlRepo" == null ]] && break
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< "${fetchGithubData["$githubComment"]}")"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
        stars) filter=(".data.user.starredRepositories.edges[$i]" ".node" ".starredAt")
          urlRepo="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$urlRepo" == null ]] && break
          nameWithOwner="$(jq -r "${filter[0]} | ${filter[1]}.nameWithOwner" <<< "${fetchGithubData["$githubComment"]}")"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[2]}" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$nameWithOwner]($urlRepo)"
          filter1="- $description"
          filter2="($datestamp)";;
          #echo "0: $filter0 1: $filter1 2: $filter2"
        gists) filter=(".data.user.gists.edges[$i]" ".node")
          urlGist="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$urlGist" == null ]] && break
          fileName="$(jq -r "${filter[0]} | ${filter[1]}.files[0].name" <<< "${fetchGithubData["$githubComment"]}")"
          owner="$(jq -r "${filter[0]} | ${filter[1]}.owner.login" <<< "${fetchGithubData["$githubComment"]}")"
          description="$(jq -r "${filter[0]} | ${filter[1]}.description" <<< "${fetchGithubData["$githubComment"]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[1]}.createdAt" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$owner/$fileName]($urlGist)"
          filter1="- $description"
          filter2="($datestamp)";;
        followers) filter=(".data.user.followers.edges[$i]" ".node")
          urlFollower="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$urlFollower" == null ]] && break
          nameFollower="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< "${fetchGithubData["$githubComment"]}")"
          workplaceFollower="$(jq -r "${filter[0]} | ${filter[1]}.company" <<< "${fetchGithubData["$githubComment"]}")"
          filter0="[$nameFollower]($urlFollower)"
          [[ "$workplaceFollower" == null ]] && filter1="- üíº Unknown"        \
            || filter1="- üíº $workplaceFollower"
          filter2="";;
        sponsors) filter=(".data.user.sponsorshipsAsMaintainer.nodes[$i]" ".sponsorEntity" ".createdAt")
          urlSponsor="$(jq -r "${filter[0]} | ${filter[1]}.url" <<< "${fetchGithubData["$githubComment"]}")"
          ## break inner loop if no data found
          [[ "$urlSponsor" == null ]] && break
          nameSponsor="$(jq -r "${filter[0]} | ${filter[1]}.login" <<< "${fetchGithubData[$githubComment]}")"
          datestamp="$(_createTimeAgo "$(jq -r "${filter[0]} | ${filter[2]}" <<< "${fetchGithubData["$githubComment"]}")")"
          filter0="[$nameSponsor]($urlSponsor)"
          filter1="($datestamp)"
          filter2="";;
        languages)
          filter0="${topLanguages[$iLang]}"
          x=$((iLang+iMax[$githubComment]))
          filter1="${topLanguages[$x]}"
          [[ "$filter1" == 1 ]] && filter1="$filter1 repo"                    \
            || filter1="$filter1 repos"
          ## increment xx (iMax) to skip to percentage elements
          x=$((x+iMax[$githubComment]))
          filter2="$(_createStatusBar "${topLanguages[$x]}")   ${topLanguages[$x]}%"
          iLang+=1;;
        productiveDay)
          filter0="${productivityDay[$iDay]}"
          ## increment 7 (days) to skip to commitCount elements
          x=$((iDay+7))
          filter1="${productivityDay[$x]}"
          ## add commit or commits according to counted num
          [[ "$filter1" == 1 ]] && filter1="$filter1 commit"                  \
            || filter1="$filter1 commits"
          ## increment 7 (days) to skip to percentage elements
          x=$((x+7))
          filter2="$(_createStatusBar "${productivityDay[$x]}")   ${productivityDay[$x]}%"
          iDay+=1;;
        productiveTime)
          filter0="${productivityDaytime[$iTime]}"
          ## increment 4 (daytimes) to skip to commitCount elements
          x=$((iTime+4))
          filter1="${productivityDaytime[$x]}"
          [[ "$filter1" == 1 ]] && filter1="$filter1 commit"                  \
            || filter1="$filter1 commits"
          x=$((x+4))
          ## increment 4 (daytimes) to skip to percentage elements
          filter2="$(_createStatusBar "${productivityDaytime[$x]}")   ${productivityDaytime[$x]}%"
          iTime+=1;;
      esac

      ##DEBUG:
      #echo "0: $filter0 1: $filter1 2: $filter2"
      ## create three arrays with filter strings
      filterGithubStart+=( ["${githubComment}$i"]="$filter0" )
      filterGithubMiddle+=( ["${githubComment}$i"]="$filter1" )
      filterGithubEnd+=( ["${githubComment}$i"]="$filter2" )
    done
  done
  _writeGithubTemplate
}
############################# github write #############################
_writeGithubTemplate() {
  local content
  for githubComment in "${githubComments[@]}"; do
    ## create block
    content="$(_createGithubMarkdownBlock "$githubComment")"
    ## write block
    perl -i -0777pe "s@(<!--github-$githubComment-start-->)(\s*)(<!--github-$githubComment-end-->)@\1\n${content}\2\3@s" "$template"
  done
}
_createGithubMarkdownBlock() {
  local commentArg="$1"
  local space0=0; local space1=0; local space2=0
  for ((i = 0; i < "${iMax[$commentArg]}"; i++)); do
    ## check if data is still found, if not skip loop to avoid printing
    #empty lines
    [[ -n "${filterGithubStart["${commentArg}$i"]}" ]] || continue
    ## set space to format text for block, print first line for table
    case "$commentArg" in
      languages) ## tables:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Primary Language | Repo [count] | Relative Repo [bar chart] | Relative Repo [%] |"
        ## markdown block:
        else
          space0=30; space1=30
        fi;;
      productiveDay) ## tables:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Weekday | Commit [count] | Relative Commit [bar chart] | Relative Commit [%] |"
        ## markdown block:
        else
          space0=30; space1=30
        fi;;
      productiveTime) ## tables:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Daytime | Commit [count] | Relative Commit [bar chart] | Relative Commit [%] |"
        ## markdown block:
        else
          space0=32; space1=30
        fi;;
    esac
    ## print block or table
    case "$commentArg" in
      languages|productiveDay|productiveTime) ## table or markdown block print:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "|:-:|:-:|:-:|:-:|"
          printf "| %s | %s | %s | %s |\n" "${filterGithubStart["${commentArg}$i"]}" "${filterGithubMiddle["${commentArg}$i"]}" "${filterGithubEnd["${commentArg}$i"]:0:25}" "${filterGithubEnd["${commentArg}$i"]:28}"
        else
          [[ $i -eq 0 ]] && printf "%s\n" '```'
          printf "‚Ä¢ %-*s %-*s %-*s\n" $space0 "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2                        "${filterGithubEnd["${commentArg}$i"]}"
          ## add closing block ``` at last line
          [[ $i -eq $((iMax[$commentArg]-1)) ]] && printf "%s\n" '```'
        fi;;
      *) ## generic markdown list print:
        printf "* %-*s %-*s %-*s\n" $space0 "${filterGithubStart["${commentArg}$i"]}" $space1 "${filterGithubMiddle["${commentArg}$i"]}" $space2 "${filterGithubEnd["${commentArg}$i"]}";;
    esac
  done
}
########################### github pre filter ##########################
_filterGithubLanguages() {
  local -A reposCount; local -A percentage
  ## if response of primary language is null it does not give "name": "foo"
  ## line, hence directly greping name with wc works
  local -i totalReposCount=$(grep -c '"name"' <<< "${fetchGithubData[languages]}")
  local language; local -i totalLanguagesCount=0
  ## count repos per language
  while read -r line; do
    if [[ "$line" =~ \"name\":.* ]]; then
      language="$(grep -o ':.*' <<< "$line" | sed 's|^...||' | tr -d '"')"
      reposCount["$language"]=$((reposCount[$language]+1))
    fi
  done < <(echo "${fetchGithubData[languages]}")
  ## calculate percentage
  for language in "${!reposCount[@]}"; do
    percentage["$language"]="$(printf "%.2f\n" "$(bc -l <<< "(${reposCount[$language]} / $totalReposCount) * 100")")"
    totalLanguagesCount+=1
  done
  echo "${totalLanguagesCount};${!reposCount[*]};${reposCount[*]};${percentage[*]}"
}
_filterGithubProductiveDay() {
  local -A commitCount; local -A percentage
  local -a weekdays=( "Monday" "Tuesday" "Wednesday" "Thursday" "Friday" "Saturday" "Sunday" )
  local -i totalCommitCount=$(grep -c "committedDate" <<< "${fetchGithubData[productiveDay]}")
  local datestamp; local weekday
  ## count commits per weekday
  while read -r line; do
    if [[ "$line" =~ committedDate.* ]]; then
      datestamp="$(grep -o ':.*Z' <<< "$line" | sed 's|^...||')"
      weekday="$(date -d "$datestamp" +%A)"
      commitCount["$weekday"]=$((commitCount[$weekday]+1))
    fi
  done < <(echo "${fetchGithubData[productiveDay]}")
  #for weekday in "${!commitCount[@]}"; do
  #  echo "Commits on $weekday: ${commitCount[$weekday]}"
  #done
  ## calculate percentage of counted weekdays
  for weekday in "${weekdays[@]}"; do
    if [[ -z "${commitCount["$weekday"]}" ]]; then
      commitCount["$weekday"]="0"
      percentage["$weekday"]="0.00"
    else
      percentage["$weekday"]="$(printf "%.2f\n" "$(bc -l <<< "(${commitCount[$weekday]} / $totalCommitCount) * 100")")"
    fi
  done
  echo "${weekdays[*]};${commitCount[*]};${percentage[*]}"
}
_filterGithubProductiveTime() {
  local -A commitCount; local -A percentage
  local -i totalCommitCount=$(grep -c "committedDate" <<< "${fetchGithubData[productiveDay]}")
  local datestamp; local timestamp; local -i hours; local -i minutes
  local -a daytimes=( "Morning" "Daytime" "Evening" "Night" )
  ## count commits per daytime
  while read -r line; do
    if [[ "$line" =~ committedDate.* ]]; then
      datestamp="$(grep -o ':.*Z' <<< "$line" | sed 's|^...||')"
      ## truncate date from datestamp, only time needed
      timestamp="${datestamp##*T}"
      ## get hours
      hours="$(cut -d: -f1 <<< "$timestamp")"
      ## get minutes, sed needed to rm first 0 for minutes 01-09 otherwise remainder errors, minute 00 is fine just one 0 gets removed
      minutes="$(cut -d: -f2 <<< "$timestamp" | sed 's|^0||')"
      #echo $timestamp
      #echo $hours-$minutes
      if [[ "$minutes%60" -ge 30 ]]; then
        hours+=1
        [[ "$hours" -eq 24 ]] && hours=0
      fi
      #echo $hours-$minutes
      case $hours in
        [0-5]) commitCount[Night]=$((commitCount[Night]+1));;
        [6-9]|1[0-1]) commitCount[Morning]=$((commitCount[Morning]+1));;
        1[2-7]) commitCount[Daytime]=$((commitCount[Daytime]+1));;
        1[8-9]|2[0-3]) commitCount[Evening]=$((commitCount[Evening]+1));;
      esac
    fi
  done < <(echo "${fetchGithubData[productiveTime]}")
  ## calculate percentage of counted daytimes
  for daytime in "${daytimes[@]}"; do
    if [[ -z "${commitCount["$daytime"]}" ]]; then
      commitCount["$daytime"]="0"
      percentage["$daytime"]="0.00"
    else
      percentage["$daytime"]="$(printf "%.2f\n" "$(bc -l <<< "(${commitCount[$daytime]} / $totalCommitCount) * 100")")"
    fi
  done
  ## add emojis to daytimes
  daytimes=( "üåÖ Morning" "üåû Daytime" "üåá Evening" "üåÉ Night" )
  echo "${daytimes[*]};${commitCount[*]};${percentage[*]}"
}
############################# wakatime func ############################
_fetchWakaData() {
  local fetchWakaData="$(curl https://wakatime.com/api/v1/users/current/stats/last_7_days?api_key="$wakaKey" | jq '.')"
  _filterWakaData
}
_filterWakaData() {
  ##  Declare local variables: strings, integers and arrays
  local -A filterWakaName=()
  local -A filterWakaPercent=()
  local -A filterWakaText=()
  local -A filterWakaLines=()
  ## Create associative arrays with data, use comment as outer loop and
  ## line number as inner loop. Uses line number  as max. index to
  ## iterate over. The same jq filter needs to be used again, mainly
  ## because when we retrive data we don't know how many objects are
  ## coming in.
  for wakaComment in "${wakaComments[@]}"; do
    ## check if wakaComment is timezone
    if [[ "$wakaComment" == timezone ]]; then
      filterWakaLines+=( ["$wakaComment"NameLines]="1" )
      filterWakaName+=( ["${wakaComment}0"]="$(jq -r ".data.timezone" <<< "$fetchWakaData")" )
      ## skip rest of loop for timezone
      continue
    fi
    ## Get the total number of lines for each data element and store it
    ## in associative array. Since each element is on a own line the line
    ## number represent the number of elements for each comment.
    filterWakaLines+=( ["$wakaComment"NameLines]="$(jq -r ".data.$wakaComment | .[] | .name" <<< "$fetchWakaData" | wc -l)" )
    filterWakaLines+=( ["$wakaComment"PercentLines]="$(jq -r ".data.$wakaComment | .[] | .percent" <<< "$fetchWakaData" | wc -l)" )
    filterWakaLines+=( ["$wakaComment"TextLines]="$(jq -r ".data.$wakaComment | .[] | .text" <<< "$fetchWakaData" | wc -l)" )
    ## test if lines per wakaComment are the same on each filtered variable, or continue with next comment
    [[ ${filterWakaLines["$wakaComment"NameLines]} -eq ${filterWakaLines["$wakaComment"PercentLines]} && \
      ${filterWakaLines["$wakaComment"NameLines]} -eq ${filterWakaLines["$wakaComment"TextLines]} ]] || break
    ## Create associavtive array from data: Name, Percentage, Timestamp
    ## loops over max. elements found per comment
    for ((i = 0; i < "${filterWakaLines["${wakaComment}NameLines"]}"; i++)); do
      filterWakaName+=( ["${wakaComment}$i"]="$(jq -r ".data.$wakaComment | .[$i] | .name" <<< "$fetchWakaData")" )
      filterWakaPercent+=( ["${wakaComment}$i"]="$(jq -r ".data.$wakaComment | .[$i] | .percent" <<< "$fetchWakaData")" )
      filterWakaPercent["${wakaComment}$i"]="$(_createStatusBar "${filterWakaPercent["${wakaComment}$i"]}")   ${filterWakaPercent["${wakaComment}$i"]}%"
      filterWakaText+=( ["${wakaComment}$i"]="$(jq -r ".data.$wakaComment | .[$i] | .text" <<< "$fetchWakaData")" )
    done
  done
  ##DEBUG:
  #echo "${filterWakaName[*]} ${filterWakaPercent[*]} ${filterWakaText[*]}"
_writeWakaTemplate
}
_writeWakaTemplate() {
  local callFunction
  if [[ "${flags[h]}" == "htmlBlockList" ]]; then
    callFunction="_createWakaHtmlBlock"
  else
    callFunction="_createWakaMarkdownBlock"
  fi
  for wakaComment in "${wakaComments[@]}"; do
    content="$($callFunction "$wakaComment")"
    perl -i -0777pe "s@(<!--wakatime-$wakaComment-start-->)(\s*)(<!--wakatime-$wakaComment-end-->)@\1\n${content}\2\3@s" "$template"
  done
}
_createWakaMarkdownBlock() {
  local commentArg="$1"
  local space0=30; local space1=30; local space2=0
  for ((i = 0; i < "${filterWakaLines["${commentArg}NameLines"]}"; i++)); do
    ## check if data is still found, if not skip loop to avoid printing
    #empty lines
    [[ -n "${filterWakaName["${commentArg}$i"]}" ]] || continue
    ## set space for formatting text and first line/header for table
    case "$commentArg" in
      languages) ## tables:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Language | Time Spent [hrs:mins] | Relative Time Spent [bar chart] | Relative Time Spent [%] |"
        fi;;
      projects) ## tables:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Project | Time Spent [hrs:mins] | Relative Time Spent [bar chart] | Relative Time Spent [%] |"
        fi;;
      editors) ## tables:
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Editor | Time Spent [hrs:mins] | Relative Time Spent [bar chart] | Relative Time Spent [%] |"
        fi;;
      operating_systems) ## tables: 
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "| Operating System | Time Spent [hrs:mins] | Relative Time Spent [bar chart] | Relative Time Spent [%] |"
        fi;;
      timezone) space0=0; space1=0;;
    esac
    ## print statements:
    case "$commentArg" in
      timezone) ## print list:
        printf "* %-*s %-*s %-*s\n" $space0 "${filterWakaName["${commentArg}$i"]}" $space1 "${filterWakaText["${commentArg}$i"]}" $space2 "${filterWakaPercent["${commentArg}$i"]}";;
      *) ## print block or table
        if [[ "${flags[t]}" == "markdownBlockTable" ]]; then
          [[ $i -eq 0 ]] && printf "%s\n" "|:-:|:-:|:-:|:-:|"
          printf "| %s | %s | %s | %s |\n" "${filterWakaName["${commentArg}$i"]}" "${filterWakaText["${commentArg}$i"]}" "${filterWakaPercent["${commentArg}$i"]:0:25}"  "${filterWakaPercent["${commentArg}$i"]:28}"
        else
          [[ $i -eq 0 ]] && printf "%s\n" '```'
          printf "‚Ä¢ %-*s %-*s %-*s\n" $space0 "${filterWakaName["${commentArg}$i"]}" $space1 "${filterWakaText["${commentArg}$i"]}" $space2                            "${filterWakaPercent["${commentArg}$i"]}"
          ## FIXME add closing block ``` at last line
          [[ $i -eq $((filterWakaLines["${commentArg}NameLines"]-1)) ]] && printf "%s\n" '```'
        fi;;
    esac
  done
}
_createWakaHtmlBlock() {
  ##FIXME DRY maybe it's possible to only have one generic function
  ## _createHtmlBlock which works for all services. And uses code it has
  ## in common with other services.
  local commentArg="$1"
  local languagesHtmlBlock='<h4>üí¨ Languages:</h4>'
  local editorsHtmlBlock='<h4>üìù Editors:</h4>'
  local operating_systemsHtmlBlock='<h4>üíª Operating Systems:</h4>'
  local projectsHtmlBlock='<h4>üå± Projects:</h4>'
  local timezoneHtmlBlock='<h4>üïê Timezone:</h4>'
  ## Indirect reference to assign variables in loop.
  local -n htmlBlock=${commentArg}HtmlBlock
  if [[ "$commentArg" == timezone ]]; then
    htmlBlock+="\n<span>${filterWakaName["${commentArg}0"]:2}</span>"
    printf "%s" "$htmlBlock" && return 0
  fi
  for ((i = 0 ; i < "${filterWakaLines["${commentArg}NameLines"]}" ; i++)); do
    htmlBlock+="\n<span>${filterWakaName["${commentArg}$i"]}</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>${filterWakaText["${commentArg}$i"]}</span>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<span>${filterWakaPercent["${commentArg}$i"]}</span>"
  done
  printf "%s" "$htmlBlock"
}
########################### general func end ###########################
_writeReadme() {
  ## Update new API data/content into readme
  cat "$template" > "$readme"
  _cleanUpFiles
}
_cleanUpFiles() {
  local -a comments
  for service in "${services[@]}"; do
    [[ $service == github ]] && comments=("${githubComments[@]}")
    [[ $service == wakatime ]] && comments=("${wakaComments[@]}")
    for comment in "${comments[@]}"; do
      ## remove comments from README.md
      sed -i "/<!--$service-$comment-start-->/d" "$readme"
      sed -i "/<!--$service-$comment-end-->/d" "$readme"
      ## remove content between comments from template
      perl -i -0777pe "s@(<!--$service-$comment-start-->)(\s*).*?(\s*)(<!--$service-$comment-end-->)@\1\3\4@s" "$template"
    done
  done
}
_main
